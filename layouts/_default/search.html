{{ define "main" }}
<main id="main">
  <section id="search-root" class="page-content" data-index-url="{{ "index.json" | relURL }}">
    <header class="page-header">
      <h1 class="page-title">Recherche</h1>

      <div class="searchbar" style="display:flex; gap:.5rem; align-items:center; margin:.75rem 0 0">
        <input
          id="search-input"
          type="search"
          inputmode="search"
          placeholder="Tape ta recherche…  (exemples :  +flag  -root  &quot;cat user.txt&quot; )"
          autocomplete="off"
          style="flex:1; padding:.6rem .8rem; border:1px solid var(--border); border-radius:.6rem;"
          aria-label="Rechercher"
        />
      </div>

      <div id="search-stats" style="margin:.5rem 0; font-size:.95rem; opacity:.85;"></div>
      <div id="search-hint" style="margin:.25rem 0 .75rem 0; font-size:.9rem; color:var(--secondary);"></div>

      <p style="margin:.25rem 0 0; font-size:.9rem; opacity:.7;">
        Astuces : <kbd>↑</kbd>/<kbd>↓</kbd> pour sélectionner, <kbd>Entrée</kbd> pour ouvrir (Ctrl/⌘+Entrée = nouvel onglet),
        <strong><kbd>Esc</kbd> pour quitter le surlignage</strong>.
      </p>
    </header>

    <ul id="search-results" class="post-list" style="list-style:none; padding:0; margin:1rem 0 2rem 0;"></ul>
  </section>
</main>

<style>
  .post-entry{transition:background-color .15s ease, box-shadow .15s ease;}
  .post-entry:hover{background:var(--entry); box-shadow:0 1px 0 rgba(0,0,0,.03) inset;}
  .post-entry.is-active{outline:2px solid var(--border); box-shadow:0 0 0 3px rgba(0,0,0,.05)}
  mark{padding:0 .15em; border-radius:.2em;}
</style>

<script>
(function(){
  // === Paramètres performance (ajuste si besoin) ===
  const MAX_RESULTS = 400;           // dureté : max occurrences rendues
  const MAX_CONTENT_LEN = 60000;     // on tronque le contenu par page
  const DEBOUNCE_MS = 300;           // délai frappe -> recherche
  const QUERY_MAX_LEN = 200;         // évite requêtes monstrueuses

  const MANIFEST_KEY = 'HL_MANIFEST_V1';
  const root = document.getElementById('search-root');
  const input = document.getElementById('search-input');
  const resultsEl = document.getElementById('search-results');
  const statsEl = document.getElementById('search-stats');
  const hintEl  = document.getElementById('search-hint');
  const rawUrl = root.dataset.indexUrl || '/index.json';
  const indexUrl = rawUrl.startsWith('/') ? rawUrl : '/' + rawUrl;

  // --- Utils
  const escapeHTML = (s) => (s||'').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));
  const norm = (s) => (s||"").toString().normalize('NFKD').toLowerCase();
  const strip = (s) => (s||"").replace(/<[^>]+>/g,' ');
  const uniq = (arr) => Array.from(new Set(arr));
  const clamp = (n, a, b) => Math.min(Math.max(n, a), b);

  // --- Parsing avec opérateurs
  function parseQuery(q){
    q = (q||'').trim();
    if (!q) return {phrases:[], must:[], terms:[], not:[]};

    const phrases = [];
    const phraseRe = /"([^"]+)"/g; let m;
    while((m = phraseRe.exec(q))) phrases.push(m[1]);

    const cleaned = q.replace(/"([^"]+)"/g,' ').trim();
    const tokens = cleaned ? cleaned.split(/\s+/) : [];

    const must = [], not = [], terms = [];
    for (const t of tokens){
      if (t.startsWith('+') && t.length>1) must.push(t.slice(1));
      else if (t.startsWith('-') && t.length>1) not.push(t.slice(1));
      else if (t) terms.push(t);
    }
    return {phrases: uniq(phrases), must: uniq(must), terms: uniq(terms), not: uniq(not)};
  }

  function matchesQuery(text, q){
    const t = norm(text);
    for (const p of q.phrases){ if (!t.includes(norm(p))) return false; }
    for (const w of q.terms){   if (!t.includes(norm(w))) return false; }
    for (const m of q.must){    if (!t.includes(norm(m))) return false; }
    for (const n of q.not){     if (t.includes(norm(n)))  return false; }
    return (q.phrases.length + q.terms.length + q.must.length) > 0;
  }

  function findAllMatchPositions(text, queryParts){
    const raw = strip(text||'');
    const t = norm(raw);
    const needles = uniq([...queryParts.phrases, ...queryParts.terms, ...queryParts.must])
      .map(norm).filter(Boolean);
    const positions = [];
    for (const n of needles){
      let from = 0;
      while (true){
        const i = t.indexOf(n, from);
        if (i === -1) break;
        positions.push({start:i, end:i+n.length});
        from = i + Math.max(1, n.length);
      }
    }
    positions.sort((a,b)=>a.start - b.start || b.end - a.end);
    return positions;
  }

  function snippetAtPosition(text, pos, queryParts, radius=90){
    const raw = strip(text||'');
    const start = clamp(pos.start - radius, 0, Math.max(0, raw.length-1));
    const end   = clamp(pos.end   + radius, 0, raw.length);
    let slice = raw.slice(start, end);
    const needles = uniq([...queryParts.phrases, ...queryParts.terms, ...queryParts.must])
      .sort((a,b)=>b.length-a.length);
    let html = escapeHTML(slice);
    for (const n of needles){
      if (!n) continue;
      const re = new RegExp(`(${n.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')})`, 'ig');
      html = html.replace(re, '<mark>$1</mark>');
    }
    return (start>0?'…':'') + html + (end<raw.length?'…':'');
  }

  function showStats(occCount, pageCount, ms){
    const base = (occCount === 0 && input.value.trim() === '') ? '' : `${occCount} occurrence(s) dans ${pageCount} page(s)`;
    statsEl.textContent = base ? `${base} — ${ms.toFixed(1)} ms` : '';
  }

  // --- Données & état
  let DATA = [];           // {title, content, summary, permalink}
  let ready = false;
  let manifestRef = null;  // tient le dernier manifest pour le click handler

  // ---- Rendu (séparé, pas de ré-attachment des écouteurs)
  function renderResults(occs, qTerm, t0){
    resultsEl.innerHTML = '';
    if (!occs.length){
      showStats(0, 0, performance.now()-t0);
      return;
    }

    // Cap dur de sécurité pour éviter le gel du DOM
    if (occs.length > MAX_RESULTS) {
      occs = occs.slice(0, MAX_RESULTS);
      hintEl.textContent = `Affichage limité à ${MAX_RESULTS} occurrences (affine la recherche pour plus de précision).`;
    } else {
      hintEl.textContent = '';
    }

    occs.forEach((oc, gidx) => {
      const li = document.createElement('li');
      const title = escapeHTML(oc.page.title || oc.page.permalink || '(sans titre)');
      const url = (oc.page.permalink || '#')
                + '?highlight=' + encodeURIComponent(qTerm)
                + '&highlightIndex=' + encodeURIComponent(oc.highlightIndex);
      const snippet = snippetAtPosition(oc.contextText, {start:oc.start, end:oc.end}, parseQuery(qTerm), 100);

      li.innerHTML = `
        <article class="post-entry" style="border:1px solid var(--border); border-radius:.6rem; padding:1rem;">
          <header class="entry-header"><h2 class="entry-hint-parent" style="margin:0 0 .25rem 0;">
            <a class="entry-title" href="${url}" data-gidx="${gidx}">${title}</a>
          </h2></header>
          <div class="entry-content" style="margin:.2rem 0 .6rem 0; line-height:1.6;">
            <a href="${url}" data-gidx="${gidx}" style="text-decoration:none; color:inherit;">${snippet}</a>
          </div>
        </article>
      `;
      resultsEl.appendChild(li);
    });

    const pagesWithOcc = new Set(occs.map(o => o.page.permalink || o.page.title)).size;
    showStats(occs.length, pagesWithOcc, performance.now() - t0);

    // Sauvegarde du manifest pour le click handler (attaché UNE FOIS plus bas)
    manifestRef = {
      q: qTerm,
      items: occs.map(oc => ({ url: oc.page.permalink || '#', index: oc.highlightIndex })),
      ts: Date.now()
    };
  }

  // ---- Moteur de recherche (sans attacher d'écouteurs à chaque appel)
  function searchNow(q){
    const t0 = performance.now();
    if (!ready){
      resultsEl.innerHTML = '';
      showStats(0, 0, performance.now()-t0);
      return;
    }
    if (!q || !q.trim() || q.length > QUERY_MAX_LEN){
      resultsEl.innerHTML = '';
      showStats(0, 0, performance.now()-t0);
      if (q && q.length > QUERY_MAX_LEN) hintEl.textContent = `Requête trop longue (${q.length} > ${QUERY_MAX_LEN}).`;
      return;
    }

    const qp = parseQuery(q);
    if ((qp.phrases.length+qp.terms.length+qp.must.length+qp.not.length)===0){
      resultsEl.innerHTML = '';
      showStats(0, 0, performance.now()-t0);
      return;
    }

    // Filtrage des pages candidates par titre+contenu (contenu tronqué pour perf)
    const candidatePages = DATA.filter(it => {
      const hay = (it.title||'') + ' ' + ( (it.content||it.summary||'').slice(0, MAX_CONTENT_LEN) );
      return matchesQuery(hay, qp);
    });

    // Comptage & occurrences
    const perPageCount = new Map(); // permalink -> count
    let occs = [];
    for (const page of candidatePages){
      const key = page.permalink || page.title || Math.random().toString(36).slice(2);

      // Titre
      const titleText = page.title || '';
      const titleMatches = findAllMatchPositions(titleText, qp);
      for (const p of titleMatches){
        const idx = (perPageCount.get(key) || 0);
        occs.push({page, start:p.start, end:p.end, contextText:titleText, highlightIndex: idx, inTitle:true});
        perPageCount.set(key, idx + 1);
      }

      // Contenu / résumé (tronqué)
      const contentText = (page.content || page.summary || '').slice(0, MAX_CONTENT_LEN);
      const contentMatches = findAllMatchPositions(contentText, qp);
      for (const p of contentMatches){
        const idx = (perPageCount.get(key) || 0);
        occs.push({page, start:p.start, end:p.end, contextText:contentText, highlightIndex: idx, inTitle:false});
        perPageCount.set(key, idx + 1);
      }
    }

    // Tri : occurrences dans le titre d’abord
    occs.sort((a,b) => (b.inTitle?1:0) - (a.inTitle?1:0));

    // Rendu + manifest (click handler lit manifestRef, pas besoin de le ré-attacher)
    renderResults(occs, q.trim(), t0);
  }

  // --- Debounce (attaché UNE FOIS)
  let debounceTimer = null;
  input.addEventListener('input', () => {
    const val = input.value;
    window.clearTimeout(debounceTimer);
    debounceTimer = window.setTimeout(() => {
      // Laisse le thread respirer si gros index
      if ('requestIdleCallback' in window){
        requestIdleCallback(() => searchNow(val), { timeout: 500 });
      } else {
        searchNow(val);
      }
    }, DEBOUNCE_MS);
  });

  // --- Navigation clavier dans la liste (attaché UNE FOIS)
  (function attachKbdNav(){
    let sel = -1;
    function setSel(i){
      const links = resultsEl.querySelectorAll('a.entry-title');
      if (!links.length) return;
      sel = clamp(i, 0, links.length-1);
      links.forEach(a => a.closest('.post-entry').classList.remove('is-active'));
      links[sel].closest('.post-entry').classList.add('is-active');
      links[sel].scrollIntoView({block:'nearest', inline:'nearest'});
    }
    function openSel(newTab){
      const links = resultsEl.querySelectorAll('a.entry-title');
      if (!links.length || sel < 0) return;
      const a = links[sel];
      try { sessionStorage.setItem(MANIFEST_KEY, JSON.stringify(manifestRef)); } catch {}
      if (newTab) window.open(a.href, '_blank');
      else window.location.href = a.href;
    }
    input.addEventListener('keydown', (e)=>{
      if (e.key === 'ArrowDown'){ e.preventDefault(); setSel(sel+1); }
      else if (e.key === 'ArrowUp'){ e.preventDefault(); setSel(sel-1); }
      else if (e.key === 'Enter' && sel >= 0){ e.preventDefault(); openSel(e.ctrlKey || e.metaKey); }
    });
  })();

  // --- Click handler (attaché UNE FOIS)
  resultsEl.addEventListener('click', (e)=>{
    const a = e.target.closest('a[data-gidx]');
    if (!a) return;
    try { sessionStorage.setItem(MANIFEST_KEY, JSON.stringify(manifestRef)); } catch {}
  });

  // --- Chargement de l'index (UNE FOIS)
  fetch(indexUrl, {credentials:'same-origin'}).then(r => {
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    return r.json();
  }).then(json => {
    const arr = Array.isArray(json) ? json : (json?.pages || []);
    DATA = arr.map(p => ({
      title: p.title || p.Title || '',
      content: p.content || p.Content || '',
      summary: p.summary || p.Summary || '',
      permalink: p.permalink || p.Permalink || p.href || '',
    }));
    ready = true;

    // Pré-remplir depuis ?q=
    const urlQ = new URLSearchParams(location.search).get('q');
    if (urlQ) { input.value = urlQ; searchNow(urlQ); }
  }).catch(err => {
    hintEl.textContent = `Erreur de chargement de l’index (${indexUrl}) : ${err.message}`;
  });
})();
</script>
{{ end }}
