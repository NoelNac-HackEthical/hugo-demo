{{- define "main" -}}
<main id="main" class="max-w-3xl mx-auto px-4 py-10">
  <h1 class="text-4xl font-bold mb-6">{{ .Title | default "Recherche" }}</h1>

  <input
    id="search-input"
    type="search"
    placeholder='{{ site.Params.searchPlaceholder | default "Rechercher..." }}'
    class="w-full text-lg px-4 py-3 rounded border"
    autocomplete="off"
  />

  <div id="search-results" class="mt-8 space-y-6"></div>
</main>

{{/* charger Fuse.js depuis le thème PaperMod */}}
{{- $fuse := resources.Get "js/fuse.basic.min.js" | fingerprint -}}
<script defer src="{{ $fuse.RelPermalink }}"></script>

<script>
document.addEventListener('DOMContentLoaded', async () => {
  const input = document.getElementById('search-input');
  const resultsEl = document.getElementById('search-results');

  // Charger l'index JSON généré par Hugo
  const indexUrl = "{{ "index.json" | relURL }}";
  let pages = [];
  try {
    const r = await fetch(indexUrl, { cache: 'no-store' });
    pages = await r.json();
  } catch {
    resultsEl.innerHTML = "<p>Impossible de charger l’index.</p>";
    return;
  }

  // 1) Moteur exact (extended search)
  const fuseExact = new window.Fuse(pages, {
    includeMatches: true,
    useExtendedSearch: true,
    ignoreLocation: true,
    minMatchCharLength: 1,
    keys: [
      { name: "title",   weight: 0.2 },
      { name: "tags",    weight: 0.2 },
      { name: "summary", weight: 0.6 },
      { name: "content", weight: 0.8 }
    ]
  });

  // 2) Moteur flou (fallback)
  const fuseFuzzy = new window.Fuse(pages, {
    includeMatches: true,
    threshold: 0.3,
    ignoreLocation: true,
    minMatchCharLength: 1,
    keys: [
      { name: "title",   weight: 0.4 },
      { name: "tags",    weight: 0.3 },
      { name: "summary", weight: 0.5 },
      { name: "content", weight: 0.6 }
    ]
  });

  const fmtDate = (iso) => {
    if (!iso) return "";
    const d = new Date(iso);
    return d.toLocaleDateString('fr-FR', { year: 'numeric', month: 'long', day: 'numeric' });
  };

  // Extrait court basé sur les indices Fuse — priorité content puis summary
  const makeSnippetFromMatches = (matches, radius = 40) => {
    if (!matches || !matches.length) return "";
    const m = matches.find(x => x.key === "content") || matches.find(x => x.key === "summary") || matches[0];
    if (!m?.value || !m.indices?.length) return "";
    const text = m.value.replace(/\s+/g, " ");
    const [s, e] = m.indices[0]; // première occurrence
    const start = Math.max(0, s - radius);
    const end   = Math.min(text.length, e + 1 + radius);
    const before = (start > 0 ? "…" : "") + text.slice(start, s);
    const hit    = text.slice(s, e + 1);
    const after  = text.slice(e + 1, end) + (end < text.length ? "…" : "");
    return `${before}<strong style="color:gold;">${hit}</strong>${after}`;
  };

  const render = (items) => {
    if (!items.length) { resultsEl.innerHTML = "<p>Aucun résultat.</p>"; return; }
    resultsEl.innerHTML = items.map(({ item, matches }) => {
      const snippet = makeSnippetFromMatches(matches, 40);
      const date = fmtDate(item.date || item.lastmod);
      const tags = (item.tags || []).map(t => `<span class="tag">#${t}</span>`).join(" ");
      return `
        <article class="search-hit">
          <h3 class="hit-title"><a href="${item.permalink}">${item.title}</a></h3>
          ${date || tags ? `<div class="hit-meta">${[date, tags].filter(Boolean).join(" · ")}</div>` : ""}
          ${snippet ? `<p class="hit-snippet">${snippet}</p>` : ""}
        </article>
      `;
    }).join("");
  };

  // Construire un pattern exact (apostrophe = "exact substring" dans Fuse)
  const buildExactPattern = (q) =>
    q.split(/\s+/).filter(Boolean).map(t => `'${t}`).join(' ');

  input.addEventListener('input', (e) => {
    const q = e.target.value.trim();
    if (q.length < 2) { resultsEl.innerHTML = ""; return; }

    const pattern = buildExactPattern(q);           // ex: "user.txt htb" -> "'user.txt 'htb"
    let found = fuseExact.search(pattern).slice(0, 50);

    if (!found.length) {
      // Fallback: recherche floue en nettoyant légèrement la requête
      const q2 = q.replace(/[^0-9A-Za-zÀ-ÖØ-öø-ÿ._\- ]+/g, " ").trim();
      found = fuseFuzzy.search(q2).slice(0, 50);
    }
    render(found);
  });
});
</script>

<style>
/* lisible en dark/light mode via variables PaperMod */
#search-input { color: var(--content); background: var(--theme); border: 1px solid var(--border); caret-color: var(--content); }
#search-input::placeholder { color: var(--secondary); opacity: .85; }
.search-hit .hit-title { font-size: 1.15rem; margin: 0 0 .25rem 0; }
.search-hit .hit-meta { opacity:.75; font-size:.95rem; margin-bottom:.35rem; }
.search-hit .hit-snippet { margin:0; line-height:1.5; }
.tag { font-size:.85rem; opacity:.85; margin-right:.35rem; white-space:nowrap; }
</style>
{{- end -}}
