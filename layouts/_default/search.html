{{ define "main" }}
<main id="main" class="main">
  <article class="post-single">
    <header class="post-header">
      <h1 class="post-title">Search</h1>
      <div class="post-meta">Occurrences exactes + fallback flou (Fuse basic)</div>
    </header>

    <section class="content">
      {{/* URL d'index absolue, compatible mono/multi-langues */}}
      {{- $prefix := .Site.LanguagePrefix -}}
      {{- if not (hasPrefix $prefix "/") -}}{{- $prefix = printf "/%s" $prefix -}}{{- end -}}
      {{- $indexURL := printf "%sindex.json" $prefix -}}

      <div id="search-root" data-index-url="{{ $indexURL }}">
        <div class="search-bar" style="display:flex;gap:.5rem;align-items:center">
          <input id="search-input" type="search" placeholder="Tape ta recherche (ex: user.txt ou &quot;cat user.txt&quot;)" autofocus
                 style="flex:1; padding:.6rem .8rem; border:1px solid var(--border); border-radius:.5rem;">
          <button id="search-clear" aria-label="Effacer" title="Effacer"
                  style="padding:.6rem .8rem; border:1px solid var(--border); border-radius:.5rem; background:transparent; cursor:pointer;">âœ•</button>
        </div>
        <p id="search-hint" style="margin:.5rem 0 0; font-size:.9rem; opacity:.75;">
          ðŸ’¡ Astuce : <code>"phrase exacte"</code> force une recherche littÃ©rale. Sans guillemets : tous les mots doivent apparaÃ®tre.
        </p>
        <div id="search-stats" style="margin:.5rem 0; font-size:.95rem;"></div>
        <ul id="search-results" style="list-style:none; padding:0; margin:1rem 0 0; display:grid; gap:1rem;"></ul>
      </div>
    </section>
  </article>
</main>

<script>
(function(){
  const root = document.getElementById('search-root');
  const input = document.getElementById('search-input');
  const clearBtn = document.getElementById('search-clear');
  const resultsEl = document.getElementById('search-results');
  const statsEl = document.getElementById('search-stats');
  const hintEl  = document.getElementById('search-hint');

  // Force ABSOLU (Ã©vite /search/index.json)
  const rawUrl = root.dataset.indexUrl || '/index.json';
  const indexUrl = rawUrl.startsWith('/') ? rawUrl : '/' + rawUrl;

  /** Utils **/
  const escapeHTML = (s) => (s||'').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));
  const norm = (s) => (s||"").toString().normalize('NFKD').toLowerCase();
  const strip = (s) => (s||"").replace(/<[^>]+>/g,' ');
  const uniq = (arr) => Array.from(new Set(arr));
  const clamp = (n, a, b) => Math.min(Math.max(n, a), b);

  // DÃ©compose la requÃªte : "phrase exacte" + mots (AND)
  function parseQuery(q){
    q = (q||'').trim();
    if (!q) return {phrases:[], terms:[]};
    const phrases = [];
    const re = /"([^"]+)"|\S+/g;
    let m;
    while((m = re.exec(q))){
      if (m[1]) phrases.push(m[1]);
    }
    const cleaned = q.replace(/"([^"]+)"/g,' ').trim();
    const terms = cleaned ? cleaned.split(/\s+/) : [];
    return {phrases: uniq(phrases), terms: uniq(terms)};
  }

  // VÃ©rifie que toutes les phrases ET tous les mots sont prÃ©sents
  function allTermsMatch(text, {phrases, terms}){
    const t = norm(text);
    for (const p of phrases){ if (!t.includes(norm(p))) return false; }
    for (const w of terms){ if (!t.includes(norm(w))) return false; }
    return (phrases.length + terms.length) > 0;
  }

  // Renvoie TOUTES les positions de matches (pour phrases et mots)
  function findAllMatchPositions(text, queryParts){
    const src = strip(text||'');
    const t = norm(src);
    const needles = uniq([...queryParts.phrases, ...queryParts.terms]).map(norm).filter(Boolean);
    const positions = [];
    for (const n of needles){
      let from = 0;
      while (true){
        const i = t.indexOf(n, from);
        if (i === -1) break;
        positions.push({start:i, end:i+n.length, needle:n});
        from = i + Math.max(1, n.length);
      }
    }
    // On trie pour un rendu logique
    positions.sort((a,b)=>a.start - b.start || b.end - a.end);
    return positions;
  }

  // Construit un extrait autour d'une position donnÃ©e, avec highlight(s)
  function snippetAtPosition(text, pos, queryParts, radius=90){
    const raw = strip(text||'');
    const start = clamp(pos.start - radius, 0, Math.max(0, raw.length-1));
    const end   = clamp(pos.end   + radius, 0, raw.length);
    let slice = raw.slice(start, end);

    // surlignage de tous les needles (longs d'abord)
    const needles = uniq([...queryParts.phrases, ...queryParts.terms]).sort((a,b)=>b.length-a.length);
    let html = escapeHTML(slice);
    for (const n of needles){
      if (!n) continue;
      const re = new RegExp(`(${n.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')})`, 'ig');
      html = html.replace(re, '<mark>$1</mark>');
    }
    return (start>0?'â€¦':'') + html + (end<raw.length?'â€¦':'');
  }

  // Score pour trier les occurrences (titre prioritaire puis position)
  function scoreOccurrence(page, pos){
    const title = page.title || '';
    const inTitle = (pos.in === 'title');
    const base = inTitle ? 0 : 100;
    return base + (pos.start/1000);
  }

  function renderOccurrences(occurrences, queryParts){
    resultsEl.innerHTML = '';
    for (const oc of occurrences){
      const li = document.createElement('li');
      li.className = 'search-hit';
      const title = escapeHTML(oc.page.title || oc.page.permalink || '(sans titre)');
      const url = oc.page.permalink || '#';
      const snippet = snippetAtPosition(oc.contextText, {start:oc.start, end:oc.end}, queryParts, 100);

      li.innerHTML = `
        <article class="post-entry" style="border:1px solid var(--border); border-radius:.6rem; padding:1rem;">
          <header class="entry-header"><h2 class="entry-hint-parent" style="margin:0 0 .25rem 0;">
            <a class="entry-title" href="${url}">${title}</a>
          </h2></header>
          <div class="entry-content" style="margin:.2rem 0 .6rem 0; line-height:1.6;">${snippet}</div>
          <footer class="entry-footer" style="font-size:.85rem; opacity:.75;">
            ${escapeHTML(oc.page.permalink || '')}
          </footer>
        </article>
      `;
      resultsEl.appendChild(li);
    }
  }

  function showStats(occCount, pageCount, totalIndexed, mode){
    // "x occurrences dans y pages" (+ mode)
    const modeTxt = mode ? ` Â· ${mode}` : '';
    statsEl.textContent = occCount === 0 && input.value.trim() === ''
      ? ''
      : `${occCount} occurrence(s) dans ${pageCount} page(s) Â· index ${totalIndexed}${modeTxt}`;
  }

  function fuseFallback(query, items){
    if (typeof Fuse === 'undefined') return [];
    const fuse = new Fuse(items, {
      includeScore: true,
      threshold: 0.3,
      ignoreLocation: true,
      minMatchCharLength: 2,
      keys: [
        {name:'title', weight:0.6},
        {name:'content', weight:0.3},
        {name:'summary', weight:0.2},
        {name:'tags', weight:0.1},
        {name:'categories', weight:0.1},
      ]
    });
    return fuse.search(query).map(r => r.item);
  }

  let DATA = [];
  let ready = false;

  function searchNow(q){
    const qp = parseQuery(q);
    if (!ready || (!qp.terms.length && !qp.phrases.length)){
      resultsEl.innerHTML = '';
      showStats(0, 0, DATA.length, '');
      return;
    }

    // 1) Filtrer les pages qui contiennent tous les termes/phrases
    const candidatePages = DATA.filter(it => {
      const hay = (it.title||'') + ' ' + (it.content||it.summary||'') + ' ' +
                  (Array.isArray(it.tags)?it.tags.join(' '):'') + ' ' +
                  (Array.isArray(it.categories)?it.categories.join(' '):'');
      return allTermsMatch(hay, qp);
    });

    // 2) Extraire TOUTES les occurrences par page (titre + contenu)
    const occurrences = [];
    const MAX_OCC_PER_PAGE = 50;   // sÃ©curitÃ© anti-spam
    const MAX_OCC_TOTAL    = 500;  // sÃ©curitÃ© globale

    for (const page of candidatePages){
      let countPage = 0;

      // matches dans le titre
      const titleText = page.title || '';
      const titlePositions = findAllMatchPositions(titleText, qp);
      for (const p of titlePositions){
        occurrences.push({
          page,
          in: 'title',
          start: p.start,
          end: p.end,
          contextText: titleText
        });
        countPage++;
        if (countPage >= MAX_OCC_PER_PAGE || occurrences.length >= MAX_OCC_TOTAL) break;
      }

      if (countPage < MAX_OCC_PER_PAGE && occurrences.length < MAX_OCC_TOTAL){
        // matches dans le contenu (content sinon summary)
        const contentText = (page.content || page.summary || '');
        const contentPositions = findAllMatchPositions(contentText, qp);
        for (const p of contentPositions){
          occurrences.push({
            page,
            in: 'content',
            start: p.start,
            end: p.end,
            contextText: contentText
          });
          countPage++;
          if (countPage >= MAX_OCC_PER_PAGE || occurrences.length >= MAX_OCC_TOTAL) break;
        }
      }

      if (occurrences.length >= MAX_OCC_TOTAL) break;
    }

    if (occurrences.length > 0){
      // 3) Trier les occurrences (titre dâ€™abord, puis position)
      occurrences.sort((a,b)=> {
        const sa = scoreOccurrence(a.page, a);
        const sb = scoreOccurrence(b.page, b);
        return sa - sb;
      });

      renderOccurrences(occurrences, qp);
      const pagesWithOcc = new Set(occurrences.map(o => o.page.permalink || o.page.title)).size;
      showStats(occurrences.length, pagesWithOcc, DATA.length, 'mode substring');
      return;
    }

    // 4) Fallback flou via Fuse : on liste par page (pas dâ€™occurrences)
    const fuzz = fuseFallback(q, DATA);
    resultsEl.innerHTML = '';
    if (fuzz.length){
      for (const it of fuzz.slice(0, 50)){
        const li = document.createElement('li');
        const title = escapeHTML(it.title || it.permalink || '(sans titre)');
        const url = it.permalink || '#';
        const content = it.content || it.summary || '';
        li.innerHTML = `
          <article class="post-entry" style="border:1px solid var(--border); border-radius:.6rem; padding:1rem;">
            <header class="entry-header"><h2 class="entry-hint-parent" style="margin:0 0 .25rem 0;">
              <a class="entry-title" href="${url}">${title}</a>
            </h2></header>
            <div class="entry-content" style="margin:.2rem 0 .6rem 0; line-height:1.6;">
              ${escapeHTML((content||'').slice(0,220))}${content.length>220?'â€¦':''}
            </div>
            <footer class="entry-footer" style="font-size:.85rem; opacity:.75;">
              ${escapeHTML(it.permalink || '')}
            </footer>
          </article>
        `;
        resultsEl.appendChild(li);
      }
      showStats(0, fuzz.length, DATA.length, 'mode fuse (fallback)');
    } else {
      showStats(0, 0, DATA.length, 'â€”');
    }
  }

  // DÃ©bounce
  let t = null;
  function scheduleSearch(){ clearTimeout(t); t = setTimeout(()=>searchNow(input.value), 200); }

  // Fetch index.json (mÃªme origine)
  fetch(indexUrl, {credentials:'same-origin'})
    .then(r => { if (!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); })
    .then(json => {
      DATA = (Array.isArray(json) ? json : (json?.pages || [])).map(p => ({
        title: p.title || p.Title || '',
        content: p.content || p.Content || '',
        summary: p.summary || p.Summary || '',
        permalink: p.permalink || p.Permalink || p.href || '',
        tags: p.tags || p.Tags || [],
        categories: p.categories || p.Categories || []
      }));
      ready = true;

      const urlQ = new URLSearchParams(location.search).get('q');
      if (urlQ) { input.value = urlQ; searchNow(urlQ); }
    })
    .catch(err => {
      hintEl.textContent = `Erreur de chargement de lâ€™index (${indexUrl}) : ${err.message}`;
      hintEl.style.color = 'var(--primary)';
    });

  // UI events
  input.addEventListener('input', scheduleSearch);
  input.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') searchNow(input.value); });
  clearBtn.addEventListener('click', ()=>{ input.value = ''; input.focus(); searchNow(''); });
  window.addEventListener('pageshow', ()=> input?.focus?.());
})();
</script>
{{ end }}

