{{- define "main" -}}
<main class="main">
  <article class="post-single">
    <header class="post-header">
      <h1 class="post-title">Recherche</h1>
    </header>

    <!-- data-no-hl : pas de surlignage dans cette page -->
    <section class="post-content" data-no-hl>
      <form id="search-form" role="search" aria-label="Recherche" style="margin-bottom:1rem">
        <input id="search-input" type="search" name="q" placeholder="Tapez votre recherche…"
               style="width:100%;max-width:640px" />
      </form>

      <div id="search-meta" style="opacity:.8;margin-bottom:.5rem"></div>
      <ul id="search-results" class="post-list" style="list-style:none;padding-left:0"></ul>
    </section>
  </article>
</main>

<script>
(function(){
  const PARAM_HL  = 'highlight';
  const PARAM_IDX = 'highlightIndex';
  const MANIFEST_KEY = 'HL_MANIFEST_V1';

  const $q    = document.getElementById('search-input');
  const $form = document.getElementById('search-form');
  const $meta = document.getElementById('search-meta');
  const $list = document.getElementById('search-results');

  const qs = new URLSearchParams(location.search);
  const initialQ = qs.get('q') || qs.get(PARAM_HL) || '';
  $q.value = initialQ;

  // ---------- Helpers ----------
  function escapeHTML(s){ return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]); }
  function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

  // Rendre RELATIF coûte que coûte (supprime schéma+host si présents)
  function toRelative(href){
    if (!href) return '/';
    // 1) Si déjà relatif
    if (/^([/?#]|\.{1,2}\/)/.test(href)) {
      // normaliser en gardant seulement pathname + hash (on gère la query plus loin)
      const u = new URL(href, location.href);
      return u.pathname + (u.hash || '');
    }
    // 2) Absolu → retirer schéma+host
    try {
      const u = new URL(href);
      return u.pathname + (u.hash || '');
    } catch {
      // 3) Inattendu → fallback brut
      return href.replace(/^https?:\/\/[^/]+/i, '');
    }
  }

  function tokenize(query){
    // phrases "..." + mots
    const needles = [];
    const re = /"([^"]+)"|(\S+)/g;
    let m; while((m = re.exec(query))) needles.push((m[1] || m[2]).trim());
    return Array.from(new Set(needles.filter(Boolean)));
  }

  async function loadIndex(){
    // /index.json (PaperMod), anti-cache de build
    const url = `/index.json?v={{ now.Unix }}`;
    const res = await fetch(url, { credentials: 'same-origin' });
    if (!res.ok) throw new Error('index.json introuvable');
    return res.json();
  }

  function scoreAndFilter(items, tokens){
    if (!tokens.length) return [];
    const res = [];
    for (const it of items){
      const title = (it.title || '').toString();
      const content = (it.content || '').toString();
      let score = 0;
      for (const t of tokens){
        const re = new RegExp(escapeRegExp(t), 'i');
        if (re.test(title))   score += 3;
        if (re.test(content)) score += 1;
      }
      if (score > 0) res.push({ it, score });
    }
    res.sort((a,b)=> b.score - a.score);
    return res.map(x => x.it);
  }

  function firstSnippet(txt, tokens, span=140){
    const t = (txt || '').toString();
    if (!t) return '';
    let idx = -1;
    for (const tk of tokens){
      const i = t.toLowerCase().indexOf(tk.toLowerCase());
      if (i !== -1 && (idx === -1 || i < idx)) idx = i;
    }
    if (idx === -1) return escapeHTML(t.slice(0, span)) + (t.length > span ? '…' : '');
    const start = Math.max(0, idx - Math.floor(span/2));
    const end = Math.min(t.length, start + span);
    let snip = t.slice(start, end);
    for (const tk of tokens){
      const re = new RegExp(escapeRegExp(tk), 'ig');
      snip = snip.replace(re, m => `<mark>${escapeHTML(m)}</mark>`);
    }
    return (start>0?'…':'') + snip + (end<t.length?'…':'');
  }

  function renderResults(items, tokens, qRaw){
    $list.innerHTML = '';
    const fr = document.createDocumentFragment();

    items.forEach((it) => {
      // PaperMod fournit souvent: permalink (absolu). Parfois: relpermalink / link / url selon config.
      const src = it.relpermalink || it.link || it.url || it.permalink || '/';
      const relPath = toRelative(src);                           // ← force RELATIF
      const href = `${relPath}?${PARAM_HL}=${encodeURIComponent(qRaw)}&${PARAM_IDX}=0`;

      const li = document.createElement('li');
      li.className = 'post-item';
      li.innerHTML = `
        <h2 class="post-title" style="font-size:1.1rem;margin:.2rem 0">
          <a class="search-hit" href="${href}">${escapeHTML(it.title || relPath)}</a>
        </h2>
        <div class="post-meta" style="opacity:.8;margin-bottom:.3rem">
          ${escapeHTML(it.date || '')}
        </div>
        <p class="post-summary" style="margin:.25rem 0 0">
          ${firstSnippet(it.content, tokens)}
        </p>
      `;
      fr.appendChild(li);
    });
    $list.appendChild(fr);

    // Mettre à jour le manifeste inter-pages (RELATIF)
    try{
      const links = Array.from(document.querySelectorAll('a.search-hit'));
      const itemsManifest = links.map((a, idx) => {
        const relHref = a.getAttribute('href');         // ← rester relatif
        const u = new URL(relHref, location.href);
        const base = u.pathname;                        // sans query
        const idxLocal = Number(u.searchParams.get(PARAM_IDX) || 0);
        return { url: base, index: idxLocal, pos: idx };
      });
      sessionStorage.setItem(MANIFEST_KEY, JSON.stringify({
        q: qRaw,
        items: itemsManifest
      }));
    }catch(e){}
  }

  async function run(){
    const qRaw = ($q.value || '').trim();
    const tokens = tokenize(qRaw);
    if (!tokens.length){
      $meta.textContent = 'Tapez des mots (ou des "phrases exactes") puis Entrée.';
      $list.innerHTML = '';
      return;
    }
    $meta.textContent = 'Recherche…';
    try{
      const idx = await loadIndex();
      const items = Array.isArray(idx) ? idx : (Array.isArray(idx.items) ? idx.items : []);
      const filtered = scoreAndFilter(items, tokens);
      $meta.textContent = `${filtered.length} résultat(s)`;
      renderResults(filtered, tokens, qRaw);

      // Met à jour l’URL ?q=… (sans recharger)
      const url = new URL(location.href);
      url.searchParams.set('q', qRaw);
      history.replaceState(null, '', url.toString());
    }catch(e){
      console.error(e);
      $meta.textContent = 'Index introuvable. Assurez-vous que /index.json est généré.';
    }
  }

  // Init
  $form.addEventListener('submit', (e)=>{ e.preventDefault(); run(); });
  if (initialQ) run();

  // Déclenche aussi sur saisie (debounce)
  let tmr = null;
  $q.addEventListener('input', ()=>{
    clearTimeout(tmr);
    tmr = setTimeout(run, 220);
  });

  // Sécurité: purge tout ancien manifest absolu hérité d’une autre env
  try {
    const prev = sessionStorage.getItem(MANIFEST_KEY);
    if (prev) {
      const obj = JSON.parse(prev);
      if (obj && Array.isArray(obj.items)) {
        // Si la 1re entrée ressemble à "http", on purge.
        const firstUrl = obj.items[0] && obj.items[0].url;
        if (typeof firstUrl === 'string' && /^https?:\/\//i.test(firstUrl)) {
          sessionStorage.removeItem(MANIFEST_KEY);
        }
      }
    }
  } catch {}
})();
</script>
{{- end -}}
