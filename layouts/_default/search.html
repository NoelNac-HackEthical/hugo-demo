{{- define "main" -}}
<main class="main">
  <article class="post-single">
    <header class="post-header">
      <h1 class="post-title">Recherche</h1>
    </header>

    <section class="post-content" data-no-hl>
      <form id="search-form" role="search" aria-label="Recherche" style="margin-bottom:1rem">
        <input id="search-input" type="search" name="q" placeholder="Tapez votre recherche…"
               style="width:100%;max-width:640px" />
      </form>

      <div id="search-meta" style="opacity:.8;margin-bottom:.5rem"></div>
      <ul id="search-results" class="post-list" style="list-style:none;padding-left:0"></ul>
    </section>
  </article>
</main>

<script>
(function(){
  const PARAM_HL = 'highlight';
  const PARAM_IDX = 'highlightIndex';
  const MANIFEST_KEY = 'HL_MANIFEST_V1';

  const $q = document.getElementById('search-input');
  const $form = document.getElementById('search-form');
  const $meta = document.getElementById('search-meta');
  const $list = document.getElementById('search-results');

  // --- Helpers ---
  const qs = new URLSearchParams(location.search);
  const initialQ = qs.get('q') || qs.get(PARAM_HL) || '';
  $q.value = initialQ;

  function escapeHTML(s){
    return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }
  function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

  function tokenize(query){
    // phrases "entre guillemets" + mots
    const needles = [];
    const re = /"([^"]+)"|(\S+)/g;
    let m; while((m = re.exec(query))) needles.push((m[1] || m[2]).trim());
    return Array.from(new Set(needles.filter(Boolean)));
  }

  function buildRelFromIndexItem(it){
    // PaperMod index.json fournit souvent 'permalink' (absolu). On dérive un chemin relatif.
    const rel = it.relpermalink || (function(){ try { return new URL(it.permalink, location.href).pathname; } catch { return it.permalink || '/'; } })();
    return rel || '/';
  }

  async function loadIndex(){
    // PaperMod sert /index.json ; on ajoute un anti-cache statique de build côté serveur.
    const url = `/index.json?v={{ now.Unix }}`;
    const res = await fetch(url, { credentials: 'same-origin' });
    if (!res.ok) throw new Error('index.json introuvable');
    return res.json();
  }

  function scoreAndFilter(items, tokens){
    if (!tokens.length) return [];
    const res = [];
    for (const it of items){
      const title = (it.title || '').toString();
      const content = (it.content || '').toString();
      let score = 0;
      for (const t of tokens){
        const re = new RegExp(escapeRegExp(t), 'i');
        if (re.test(title)) score += 3;           // match dans le titre
        if (re.test(content)) score += 1;         // match dans le contenu
      }
      if (score > 0) res.push({ it, score });
    }
    res.sort((a,b)=> b.score - a.score);
    return res.map(x => x.it);
  }

  function firstSnippet(txt, tokens, span=140){
    const t = (txt || '').toString();
    if (!t) return '';
    let idx = -1;
    for (const tk of tokens){
      const i = t.toLowerCase().indexOf(tk.toLowerCase());
      if (i !== -1 && (idx === -1 || i < idx)) idx = i;
    }
    if (idx === -1) return escapeHTML(t.slice(0, span)) + (t.length > span ? '…' : '');
    const start = Math.max(0, idx - Math.floor(span/2));
    const end = Math.min(t.length, start + span);
    let snip = t.slice(start, end);
    // mise en évidence légère dans l’aperçu (HTML dans search seulement)
    for (const tk of tokens){
      const re = new RegExp(escapeRegExp(tk), 'ig');
      snip = snip.replace(re, m => `<mark>${escapeHTML(m)}</mark>`);
    }
    return (start>0?'…':'') + snip + (end<t.length?'…':'');
  }

  function renderResults(items, tokens, qRaw){
    $list.innerHTML = '';
    const fr = document.createDocumentFragment();
    items.forEach((it, i) => {
      const rel = buildRelFromIndexItem(it);
      const href = `${rel}?${PARAM_HL}=${encodeURIComponent(qRaw)}&${PARAM_IDX}=0`; // index local = 0

      const li = document.createElement('li');
      li.className = 'post-item';
      li.innerHTML = `
        <h2 class="post-title" style="font-size:1.1rem;margin:.2rem 0">
          <a class="search-hit" href="${href}">${escapeHTML(it.title || rel)}</a>
        </h2>
        <div class="post-meta" style="opacity:.8;margin-bottom:.3rem">
          ${escapeHTML(it.date || '')}
        </div>
        <p class="post-summary" style="margin:.25rem 0 0">
          ${firstSnippet(it.content, tokens)}
        </p>
      `;
      fr.appendChild(li);
    });
    $list.appendChild(fr);

    // Manifest inter-pages (URLs RELATIVES)
    try{
      const links = Array.from(document.querySelectorAll('a.search-hit'));
      const itemsManifest = links.map((a, idx) => {
        const relHref = a.getAttribute('href');                  // ← reste relatif
        const u = new URL(relHref, location.href);
        const base = u.pathname;                                 // sans query
        const idxLocal = Number(u.searchParams.get(PARAM_IDX) || 0);
        return { url: base, index: idxLocal, pos: idx };
      });
      sessionStorage.setItem(MANIFEST_KEY, JSON.stringify({
        q: qRaw,
        items: itemsManifest
      }));
    }catch(e){}
  }

  async function run(){
    const qRaw = ($q.value || '').trim();
    const tokens = tokenize(qRaw);
    if (!tokens.length){
      $meta.textContent = 'Tapez des mots (ou des "phrases exactes") puis Entrée.';
      $list.innerHTML = '';
      return;
    }
    $meta.textContent = 'Recherche…';
    try{
      const idx = await loadIndex();
      // PaperMod met souvent le contenu dans idx[0].items ; d’autres thèmes à la racine
      const items = Array.isArray(idx) ? idx : (Array.isArray(idx.items) ? idx.items : []);
      const filtered = scoreAndFilter(items, tokens);
      $meta.textContent = `${filtered.length} résultat(s)`;
      renderResults(filtered, tokens, qRaw);
      // Met à jour l’URL ?q=…
      const url = new URL(location.href);
      url.searchParams.set('q', qRaw);
      history.replaceState(null, '', url.toString());
    }catch(e){
      console.error(e);
      $meta.textContent = 'Index introuvable. Assurez-vous que /index.json est généré.';
    }
  }

  // Initialisation
  $form.addEventListener('submit', (e)=>{ e.preventDefault(); run(); });
  if (initialQ) run();

  // Accessibilité: lancer à la volée si l’utilisateur efface/tape (debounce light)
  let tmr = null;
  $q.addEventListener('input', ()=>{
    clearTimeout(tmr);
    tmr = setTimeout(run, 220);
  });
})();
</script>
{{- end -}}

