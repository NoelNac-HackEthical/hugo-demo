{{- define "main" -}}
<main class="main search-scope">
  <style>
    /* Neutralise la mise en page 2 colonnes (TOC) sur la page de recherche */
    .search-scope .post-content { display: block !important; }
    .search-scope .post-content.toc-ready {
      display: block !important;
      grid-template-columns: none !important;
      gap: 0 !important;
    }
    .search-scope .content-col { display: contents !important; } /* remet tout en flux normal */

    /* Couleurs lisibles */
    .search-scope { color: var(--primary, #e6e6e6); }
    .search-scope .post-title,
    .search-scope .post-meta,
    .search-scope .post-summary { color: inherit; }

    /* Champ de recherche : plus grand */
    .search-scope #search-form{ margin-bottom: 1rem; }
    .search-scope input[type="search"]{
      color: var(--primary, #e6e6e6) !important;
      background: var(--entry, #1f1f22) !important;
      border: 1px solid var(--border, #4a4a4a) !important;
      border-radius: .6rem !important;
      padding: .7rem .9rem !important;
      font-size: 1.05rem !important;
      width: 100% !important;
      max-width: 760px !important;
    }
    .search-scope input[type="search"]::placeholder{
      color: var(--secondary, #9aa0a6);
      opacity: .9;
    }

    /* /search : occurrences = texte ORANGE vif (#ff9800), pas de fond */
    .search-scope mark{
      background: transparent !important;
      color: #ff9800 !important;
      font-weight: 700;
      padding: 0 .02em;
      border-radius: 2px;
    }
    /* Ciblée (celle de la ligne) = fond jaune + texte sombre */
    .search-scope mark.is-active{
      background: #ffeb3b !important;
      color: #111 !important;
      font-weight: 800;
      border-radius: 2px;
      outline: 1px solid rgba(0,0,0,.25);
    }

    .search-scope a.search-hit{
      color: var(--tag-fg, #9ecbff);
      text-decoration: underline;
      cursor: pointer;
      pointer-events: auto;
      position: relative;
      z-index: 2;
    }
    .search-scope #search-results .post-item{
      cursor: pointer;
      position: relative;
      z-index: 1;
      padding: .25rem 0;
    }
    .occ-meta{ font: 12px/1.2 monospace; opacity:.8 }
  </style>

  <article class="post-single">
    <header class="post-header">
      <h1 class="post-title">Recherche</h1>
    </header>

    <!-- On empêche le surlignage auto dans la page de recherche -->
    <section class="post-content" data-no-hl>
      <form id="search-form" role="search" aria-label="Recherche">
        <input id="search-input" type="search" name="q" placeholder="Tapez votre recherche…"/>
      </form>

      <div id="search-meta" style="opacity:.8;margin:.25rem 0 .65rem"></div>
      <ul id="search-results" class="post-list" style="list-style:none;padding-left:0"></ul>
    </section>
  </article>
</main>

<script>
(function(){
  const PARAM_HL  = 'highlight';
  const PARAM_IDX = 'highlightIndex';
  const MANIFEST_KEY = 'HL_MANIFEST_V1';

  const $q    = document.getElementById('search-input');
  const $form = document.getElementById('search-form');
  const $meta = document.getElementById('search-meta');
  const $list = document.getElementById('search-results');

  const qs = new URLSearchParams(location.search);
  const initialQ = qs.get('q') || qs.get(PARAM_HL) || '';
  $q.value = initialQ;

  function escapeHTML(s){ return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39'}[m])); }
  function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

  // Force RELATIF (strip schéma+host si présents)
  function toRelative(href){
    if (!href) return '/';
    if (/^([/?#]|\.{1,2}\/)/.test(href)) {
      const u = new URL(href, location.href);
      return u.pathname + (u.hash || '');
    }
    try { const u = new URL(href); return u.pathname + (u.hash || ''); }
    catch { return href.replace(/^https?:\/\/[^/]+/i, ''); }
  }

  function tokenize(query){
    const needles = [];
    const re = /"([^"]+)"|(\S+)/g; let m;
    while((m = re.exec(query))) needles.push((m[1] || m[2]).trim());
    return Array.from(new Set(needles.filter(Boolean)));
  }

  async function loadIndex(){
    const url = `/index.json?v={{ now.Unix }}`; // anti-cache
    const res = await fetch(url, { credentials: 'same-origin' });
    if (!res.ok) throw new Error('index.json introuvable');
    return res.json();
  }

  function scoreItems(items, tokens){
    const res = [];
    for (const it of items){
      const title = (it.title || '').toString();
      const content = (it.content || '').toString();
      let score = 0;
      for (const t of tokens){
        const re = new RegExp(escapeRegExp(t), 'i');
        if (re.test(title))   score += 3;
        if (re.test(content)) score += 1;
      }
      if (score > 0) res.push({ it, score });
    }
    res.sort((a,b)=> b.score - a.score);
    return res.map(x => x.it);
  }

  function findOccurrences(text, tokens){
    const t = (text || '').toString();
    const occ = [];
    for (const tk of tokens){
      const re = new RegExp(escapeRegExp(tk), 'gi');
      let m; while ((m = re.exec(t))) occ.push({ start: m.index, end: m.index + m[0].length });
    }
    occ.sort((a,b)=> a.start - b.start || a.end - b.end);
    const merged = [];
    for (const o of occ){
      if (merged.length && o.start <= merged[merged.length-1].end) continue;
      merged.push(o);
    }
    return merged;
  }

  function markAllInSegment(raw, tokens){
    let s = escapeHTML(raw);
    for (const tk of tokens){
      const re = new RegExp(escapeRegExp(escapeHTML(tk)), 'ig');
      s = s.replace(re, m => '<mark>' + m + '</mark>');
    }
    return s;
  }

  function snippetAroundExact(text, start, end, tokens, span=140){
    const t = (text || '').toString();
    const mid = Math.floor((start + end)/2);
    const sliceStart = Math.max(0, mid - Math.floor(span/2));
    const sliceEnd   = Math.min(t.length, sliceStart + span);

    const beforeRaw = t.slice(sliceStart, start);
    const targetRaw = t.slice(start, end);
    const afterRaw  = t.slice(end, sliceEnd);

    const before = markAllInSegment(beforeRaw, tokens);
    const target = '<mark class="is-active">' + escapeHTML(targetRaw) + '</mark>';
    const after  = markAllInSegment(afterRaw, tokens);

    return (sliceStart>0?'…':'') + before + target + after + (sliceEnd<t.length?'…':'');
  }

  function renderResults(items, tokens, qRaw){
    $list.innerHTML = '';
    const fr = document.createDocumentFragment();
    const manifestItems = [];
    let totalOcc = 0;
    let running = 0; // numérotation globale

    items.forEach((it) => {
      const src = it.relpermalink || it.link || it.url || it.permalink || '/';
      const relPath = toRelative(src);
      const text = (it.content || '').toString();
      const occs = findOccurrences(text, tokens);

      occs.forEach((o, j) => {
        running++;
        const href = `${relPath}?${PARAM_HL}=${encodeURIComponent(qRaw)}&${PARAM_IDX}=${j}`;
        const li = document.createElement('li');
        li.className = 'post-item';
        li.innerHTML = `
          <h2 class="post-title" style="font-size:1.05rem;margin:.2rem 0">
            <a class="search-hit" href="${href}">${escapeHTML(it.title || relPath)}</a>
          </h2>
          <div class="occ-meta">occurrence #${running} — ${escapeHTML(relPath)}</div>
          <p class="post-summary" style="margin:.25rem 0 0">
            ${snippetAroundExact(text, o.start, o.end, tokens)}
          </p>
        `;
        fr.appendChild(li);
        manifestItems.push({ url: relPath, index: j });
        totalOcc++;
      });
    });

    $list.appendChild(fr);

    // Forcer tous les href en RELATIF (y compris query/hash)
    Array.from(document.querySelectorAll('a.search-hit')).forEach(a => {
      const raw = a.getAttribute('href') || '';
      try {
        const u = new URL(raw, location.href);
        a.setAttribute('href', u.pathname + (u.search || '') + (u.hash || ''));
      } catch {
        a.setAttribute('href', raw.replace(/^https?:\/\/[^/]+/i, ''));
      }
    });

    try{
      sessionStorage.setItem(MANIFEST_KEY, JSON.stringify({ q: qRaw, items: manifestItems }));
    }catch{}

    $meta.textContent = `${totalOcc} occurrence(s) trouvée(s) dans ${items.length} page(s)`;

    Array.from(document.querySelectorAll('#search-results .post-item')).forEach(li => {
      const a = li.querySelector('a.search-hit'); if (!a) return;
      const href = a.getAttribute('href');
      li.addEventListener('click', (ev) => {
        if ((ev.target && ev.target.closest('a.search-hit'))) return;
        if (href) window.location.href = href;
      });
      li.tabIndex = 0;
      li.addEventListener('keydown', (ev) => { if (ev.key === 'Enter' && href) window.location.href = href; });
    });
  }

  async function run(){
    const qRaw = ($q.value || '').trim();
    const tokens = tokenize(qRaw);
    if (!tokens.length){
      $meta.textContent = 'Tapez des mots (ou des "phrases exactes") puis Entrée.';
      $list.innerHTML = '';
      return;
    }
    $meta.textContent = 'Recherche…';
    try{
      const idx = await loadIndex();
      const items = Array.isArray(idx) ? idx : (Array.isArray(idx.items) ? idx.items : []);
      const filtered = scoreItems(items, tokens);
      renderResults(filtered, tokens, qRaw);

      const url = new URL(location.href);
      url.searchParams.set('q', qRaw);
      history.replaceState(null, '', url.toString());
    }catch(e){
      console.error(e);
      $meta.textContent = 'Index introuvable. Assurez-vous que /index.json est généré.';
    }
  }

  $form.addEventListener('submit', (e)=>{ e.preventDefault(); run(); });
  if (initialQ) run();

  let tmr = null;
  $q.addEventListener('input', ()=>{
    clearTimeout(tmr);
    tmr = setTimeout(run, 220);
  });

  try {
    const prev = sessionStorage.getItem(MANIFEST_KEY);
    if (prev) {
      const obj = JSON.parse(prev);
      if (obj && Array.isArray(obj.items)) {
        const u0 = obj.items[0] && obj.items[0].url;
        if (typeof u0 === 'string' && /^https?:\/\//i.test(u0)) {
          sessionStorage.removeItem(MANIFEST_KEY);
        }
      }
    }
  } catch {}
})();
</script>
{{- end -}}

