{{- define "main" -}}
<main id="main" class="max-w-3xl mx-auto px-4 py-10">
  <h1 class="text-4xl font-bold mb-6">{{ .Title | default "Recherche" }}</h1>

  <input
    id="search-input"
    type="search"
    placeholder='{{ site.Params.searchPlaceholder | default "Rechercher..." }}'
    class="w-full text-lg px-4 py-3 rounded border"
    autocomplete="off"
  />

  <div id="search-results" class="mt-8 space-y-6"></div>
</main>

{{- $fuse := resources.Get "js/fuse.basic.min.js" | fingerprint -}}
<script defer src="{{ $fuse.RelPermalink }}"></script>

<script>
document.addEventListener('DOMContentLoaded', async () => {
  const input = document.getElementById('search-input');
  const resultsEl = document.getElementById('search-results');

  // 1) Charger l'index
  const indexUrl = "{{ "index.json" | relURL }}";
  let pages = [];
  try {
    const r = await fetch(indexUrl, { cache: 'no-store' });
    pages = await r.json();
  } catch {
    resultsEl.innerHTML = "<p>Impossible de charger l’index.</p>";
    return;
  }

  // 2) Fuse en mode "extended search" (exact match, pas de flou)
  const fuse = new window.Fuse(pages, {
    includeMatches: true,
    useExtendedSearch: true,
    ignoreLocation: true,
    minMatchCharLength: 2,
    // on garde les clés, mais on ne prendra l'extrait QUE depuis summary/content
    keys: [
      { name: "title",   weight: 0.4 },
      { name: "tags",    weight: 0.3 },
      { name: "summary", weight: 0.5 },
      { name: "content", weight: 0.6 }
    ]
  });

  const fmtDate = (iso) => {
    if (!iso) return "";
    const d = new Date(iso);
    return d.toLocaleDateString('fr-FR', { year: 'numeric', month: 'long', day: 'numeric' });
  };

  // 3) Extrait basé sur les indices Fuse, mais UNIQUEMENT summary/content
  const makeSnippetFromMatches = (matches, radius = 40) => {
    if (!matches || !matches.length) return "";
    // privilégie content puis summary
    const prefer = matches.find(m => m.key === "content") || matches.find(m => m.key === "summary") || matches[0];
    if (!prefer?.value || !prefer.indices?.length) return "";
    const text = prefer.value.replace(/\s+/g, " ");
    const [startIdx, endIdx] = prefer.indices[0];
    const start = Math.max(0, startIdx - radius);
    const end   = Math.min(text.length, endIdx + 1 + radius);
    const before = (start > 0 ? "…" : "") + text.slice(start, startIdx);
    const hit    = text.slice(startIdx, endIdx + 1);
    const after  = text.slice(endIdx + 1, end) + (end < text.length ? "…" : "");
    return `${before}<strong style="color:gold;">${hit}</strong>${after}`;
  };

  const render = (items) => {
    if (!items.length) { resultsEl.innerHTML = "<p>Aucun résultat.</p>"; return; }
    resultsEl.innerHTML = items.map(({ item, matches }) => {
      const snippet = makeSnippetFromMatches(matches, 40);
      const date = fmtDate(item.date || item.lastmod);
      const tags = (item.tags || []).map(t => `<span class="tag">#${t}</span>`).join(" ");
      return `
        <article class="search-hit">
          <h3 class="hit-title"><a href="${item.permalink}">${item.title}</a></h3>
          ${date || tags ? `<div class="hit-meta">${[date, tags].filter(Boolean).join(" · ")}</div>` : ""}
          ${snippet ? `<p class="hit-snippet">${snippet}</p>` : ""}
        </article>
      `;
    }).join("");
  };

  // 4) Construire un pattern "exact substring" pour chaque mot tapé
  //    Exemple : "user.txt htb" -> "'user.txt 'htb (apostrophe = exact substring)
  const buildPattern = (q) =>
    q.split(/\s+/).filter(Boolean).map(t => `'${t}`).join(' ');

  input.addEventListener('input', (e) => {
    const q = e.target.value.trim();
    if (q.length < 2) { resultsEl.innerHTML = ""; return; }
    const pattern = buildPattern(q);
    const found = fuse.search(pattern).slice(0, 50);
    render(found);
  });
});
</script>


<style>
#search-input { color: var(--content); background: var(--theme); border: 1px solid var(--border); caret-color: var(--content); }
#search-input::placeholder { color: var(--secondary); opacity: .85; }
.search-hit .hit-title { font-size: 1.15rem; margin: 0 0 .25rem 0; }
.search-hit .hit-meta { opacity:.75; font-size:.95rem; margin-bottom:.35rem; }
.search-hit .hit-snippet { margin:0; line-height:1.5; }
.tag { font-size:.85rem; opacity:.85; margin-right:.35rem; white-space:nowrap; }
</style>
{{- end -}}
