{{- define "main" -}}
<main class="main search-scope">
  <style>
    /* ==== Styles locaux (scopés) pour garantir la lisibilité, même en preview ==== */
    .search-scope { color: var(--primary, #e6e6e6); }
    .search-scope .post-title,
    .search-scope .post-meta,
    .search-scope .post-summary { color: inherit; }

    .search-scope input[type="search"]{
      color: var(--primary, #e6e6e6);
      background: var(--entry, #1f1f22);
      border: 1px solid var(--border, #4a4a4a);
      border-radius: .5rem;
      padding: .5rem .65rem;
    }
    .search-scope input[type="search"]::placeholder{
      color: var(--secondary, #9aa0a6);
      opacity: .9;
    }

    .search-scope mark{
      background: var(--hl-bg, #665c00);
      color: var(--primary, #fff);
      padding: 0 .08em;
      border-radius: 2px;
    }

    /* Liens de résultats visibles et cliquables */
    .search-scope a.search-hit{
      color: var(--tag-fg, #9ecbff);
      text-decoration: underline;
      cursor: pointer;
      pointer-events: auto;
      position: relative;
      z-index: 2;
    }
    /* Rendre l'item entier “cliquable” si jamais un overlay gêne */
    .search-scope #search-results .post-item{
      cursor: pointer;
      position: relative;
      z-index: 1;
    }
  </style>

  <article class="post-single">
    <header class="post-header">
      <h1 class="post-title">Recherche</h1>
    </header>

    <!-- data-no-hl : pas de surlignage par highlight.js dans la page de recherche -->
    <section class="post-content" data-no-hl>
      <form id="search-form" role="search" aria-label="Recherche" style="margin-bottom:1rem">
        <input id="search-input" type="search" name="q" placeholder="Tapez votre recherche…"
               style="width:100%;max-width:640px" />
      </form>

      <div id="search-meta" style="opacity:.8;margin-bottom:.5rem"></div>
      <ul id="search-results" class="post-list" style="list-style:none;padding-left:0"></ul>
    </section>
  </article>
</main>

<script>
(function(){
  const PARAM_HL  = 'highlight';
  const PARAM_IDX = 'highlightIndex';
  const MANIFEST_KEY = 'HL_MANIFEST_V1';

  const $q    = document.getElementById('search-input');
  const $form = document.getElementById('search-form');
  const $meta = document.getElementById('search-meta');
  const $list = document.getElementById('search-results');

  const qs = new URLSearchParams(location.search);
  const initialQ = qs.get('q') || qs.get(PARAM_HL) || '';
  $q.value = initialQ;

  // ---------- Helpers ----------
  function escapeHTML(s){
    return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }
  function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

  // Forcer RELATIF (enlève schéma + host si présents, conserve pathname + hash)
  function toRelative(href){
    if (!href) return '/';
    if (/^([/?#]|\.{1,2}\/)/.test(href)) {
      const u = new URL(href, location.href);
      return u.pathname + (u.hash || '');
    }
    try {
      const u = new URL(href);
      return u.pathname + (u.hash || '');
    } catch {
      return href.replace(/^https?:\/\/[^/]+/i, '');
    }
  }

  function tokenize(query){
    const needles = [];
    const re = /"([^"]+)"|(\S+)/g;
    let m; while((m = re.exec(query))) needles.push((m[1] || m[2]).trim());
    return Array.from(new Set(needles.filter(Boolean)));
  }

  async function loadIndex(){
    // /index.json (PaperMod) ; anti-cache de build pour les previews
    const url = `/index.json?v={{ now.Unix }}`;
    const res = await fetch(url, { credentials: 'same-origin' });
    if (!res.ok) throw new Error('index.json introuvable');
    return res.json();
  }

  function scoreAndFilter(items, tokens){
    if (!tokens.length) return [];
    const res = [];
    for (const it of items){
      const title = (it.title || '').toString();
      const content = (it.content || '').toString();
      let score = 0;
      for (const t of tokens){
        const re = new RegExp(escapeRegExp(t), 'i');
        if (re.test(title))   score += 3;
        if (re.test(content)) score += 1;
      }
      if (score > 0) res.push({ it, score });
    }
    res.sort((a,b)=> b.score - a.score);
    return res.map(x => x.it);
  }

  function firstSnippet(txt, tokens, span=140){
    const t = (txt || '').toString();
    if (!t) return '';
    let idx = -1;
    for (const tk of tokens){
      const i = t.toLowerCase().indexOf(tk.toLowerCase());
      if (i !== -1 && (idx === -1 || i < idx)) idx = i;
    }
    if (idx === -1) return escapeHTML(t.slice(0, span)) + (t.length > span ? '…' : '');
    const start = Math.max(0, idx - Math.floor(span/2));
    const end = Math.min(t.length, start + span);
    let snip = t.slice(start, end);
    for (const tk of tokens){
      const re = new RegExp(escapeRegExp(tk), 'ig');
      snip = snip.replace(re, m => `<mark>${escapeHTML(m)}</mark>`);
    }
    return (start>0?'…':'') + snip + (end<t.length?'…':'');
  }

  function renderResults(items, tokens, qRaw){
    $list.innerHTML = '';
    const fr = document.createDocumentFragment();

    items.forEach((it) => {
      // relpermalink si dispo, sinon on convertit permalink en relatif
      const src = it.relpermalink || it.link || it.url || it.permalink || '/';
      const relPath = toRelative(src);
      const href = `${relPath}?${PARAM_HL}=${encodeURIComponent(qRaw)}&${PARAM_IDX}=0`;

      const li = document.createElement('li');
      li.className = 'post-item';
      li.innerHTML = `
        <h2 class="post-title" style="font-size:1.1rem;margin:.2rem 0">
          <a class="search-hit" href="${href}">${escapeHTML(it.title || relPath)}</a>
        </h2>
        <div class="post-meta" style="opacity:.8;margin-bottom:.3rem">
          ${escapeHTML(it.date || '')}
        </div>
        <p class="post-summary" style="margin:.25rem 0 0">
          ${firstSnippet(it.content, tokens)}
        </p>
      `;
      fr.appendChild(li);
    });
    $list.appendChild(fr);

    // Normalisation finale : forcer les href en RELATIF (y compris query/hash)
    Array.from(document.querySelectorAll('a.search-hit')).forEach(a => {
      const raw = a.getAttribute('href') || '';
      try {
        const u = new URL(raw, location.href);
        const rel = u.pathname + (u.search || '') + (u.hash || '');
        a.setAttribute('href', rel);
      } catch {
        a.setAttribute('href', raw.replace(/^https?:\/\/[^/]+/i, ''));
      }
    });

    // Manifest inter-pages (RELATIF)
    try{
      const links = Array.from(document.querySelectorAll('a.search-hit'));
      const itemsManifest = links.map((a) => {
        const relHref = a.getAttribute('href'); // rester relatif
        const u = new URL(relHref, location.href);
        const base = u.pathname;                // sans query
        const idxLocal = Number(u.searchParams.get(PARAM_IDX) || 0);
        return { url: base, index: idxLocal };
      });
      sessionStorage.setItem(MANIFEST_KEY, JSON.stringify({
        q: qRaw,
        items: itemsManifest
      }));
    }catch(e){}

    // Fallback : rendre l'item entier cliquable si jamais un style bloque le <a>
    Array.from(document.querySelectorAll('#search-results .post-item')).forEach(li => {
      const a = li.querySelector('a.search-hit');
      if (!a) return;
      const href = a.getAttribute('href');
      li.addEventListener('click', (ev) => {
        if ((ev.target && ev.target.closest('a.search-hit'))) return; // clic direct sur <a>
        if (href) window.location.href = href;
      });
      li.tabIndex = 0;
      li.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter' && href) window.location.href = href;
      });
    });
  }

  async function run(){
    const qRaw = ($q.value || '').trim();
    const tokens = tokenize(qRaw);
    if (!tokens.length){
      $meta.textContent = 'Tapez des mots (ou des "phrases exactes") puis Entrée.';
      $list.innerHTML = '';
      return;
    }
    $meta.textContent = 'Recherche…';
    try{
      const idx = await loadIndex();
      const items = Array.isArray(idx) ? idx : (Array.isArray(idx.items) ? idx.items : []);
      const filtered = scoreAndFilter(items, tokens);
      $meta.textContent = `${filtered.length} résultat(s)`;
      renderResults(filtered, tokens, qRaw);

      // Met à jour l’URL ?q=… (sans recharger)
      const url = new URL(location.href);
      url.searchParams.set('q', qRaw);
      history.replaceState(null, '', url.toString());
    }catch(e){
      console.error(e);
      $meta.textContent = 'Index introuvable. Assurez-vous que /index.json est généré.';
    }
  }

  // Init
  $form.addEventListener('submit', (e)=>{ e.preventDefault(); run(); });
  if (initialQ) run();

  // Déclenche aussi sur saisie (debounce)
  let tmr = null;
  $q.addEventListener('input', ()=>{
    clearTimeout(tmr);
    tmr = setTimeout(run, 220);
  });

  // Purge d’un ancien manifest “absolu” importé d’un autre env
  try {
    const prev = sessionStorage.getItem(MANIFEST_KEY);
    if (prev) {
      const obj = JSON.parse(prev);
      if (obj && Array.isArray(obj.items)) {
        const u0 = obj.items[0] && obj.items[0].url;
        if (typeof u0 === 'string' && /^https?:\/\//i.test(u0)) {
          sessionStorage.removeItem(MANIFEST_KEY);
        }
      }
    }
  } catch {}
})();
</script>
{{- end -}}
