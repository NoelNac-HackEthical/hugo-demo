{{/* layouts/partials/extend_footer.html
     - Charge highlight.js via Hugo Pipes (minify + SRI)
     - Émet 'postcontent-ready' quand la page est prête
     - Filet : recentre l’occurrence active si besoin
     NOTE : aucun déplacement de TOC ici (on s’appuie sur le wrapper d’origine)
*/}}

{{- $hl := resources.Get "js/highlight.js" | resources.Minify | resources.Fingerprint -}}
<script defer src="{{ $hl.RelPermalink }}" integrity="{{ $hl.Data.Integrity }}"></script>

<script>
  (function(){
    function fireReady(){ try { window.dispatchEvent(new Event('postcontent-ready')); } catch(e){} }
    if (document.readyState === 'complete') {
      fireReady();
    } else {
      window.addEventListener('load', fireReady, { once:true });
    }
    // BFCache (retour arrière/avant)
    window.addEventListener('pageshow', function (ev) {
      if (ev.persisted) fireReady();
    });
  })();
</script>

<script>
  (function(){
    function recenter(){
      const t = document.querySelector('mark.__hl-target');
      if (t) { t.scrollIntoView({ behavior:'smooth', block:'center' }); return true; }
      return false;
    }
    function retry(n){
      if (recenter()) return;
      if (n < 12) setTimeout(function(){ retry(n+1); }, 120); // ~1.5s max
    }
    function kick(){
      const p = new URLSearchParams(location.search);
      if (p.has('highlight')) retry(0);
    }
    window.addEventListener('postcontent-ready', kick);
  })();
</script>

<script>
/* TOC sync + auto open/close + fin de page (robuste) + repère "milieu d'écran" */
(function () {
  const toc = document.getElementById('TableOfContents');
  if (!toc) return;

  const links = Array.from(toc.querySelectorAll('a[href^="#"]'));
  if (!links.length) return;

  /* Map id -> <a> */
  const byId = new Map();
  links.forEach(a => {
    const id = decodeURIComponent(a.getAttribute('href').slice(1));
    if (id) byId.set(id, a);
  });

  /* Marquer les <li> qui ont des enfants (chevrons + ouverture) */
  const liAll = Array.from(toc.querySelectorAll('li'));
  liAll.forEach(li => {
    if (li.querySelector(':scope > ul')) li.classList.add('has-children');
  });

  /* Headings H2/H3/H4 présents dans la TOC */
  const headings = Array.from(
    document.querySelectorAll('.post-content h2[id], .post-content h3[id], .post-content h4[id]')
  ).filter(h => byId.has(h.id));
  if (!headings.length) return;

  const lastHeading = headings[headings.length - 1];

  /* Lire --toc-stick (rem/px) pour caler les repères visuels */
  let topOffsetPx = 0;
  (function () {
    try {
      const rs = getComputedStyle(document.documentElement);
      const v = (rs.getPropertyValue('--toc-stick') || '').trim();
      const fs = parseFloat(rs.fontSize) || 16;
      if (v.endsWith('rem')) topOffsetPx = parseFloat(v) * fs;
      else if (v.endsWith('px')) topOffsetPx = parseFloat(v);
    } catch { topOffsetPx = 0; }
  })();

  let lastActiveId = null;
  let bottomLock = false; // quand true, on force le dernier titre actif

  const clearActive = () => links.forEach(a => a.classList.remove('is-active'));

  const openPathFor = (a) => {
    liAll.forEach(li => li.classList.remove('is-open'));
    let li = a.closest('li');
    while (li && li !== toc) {
      li.classList.add('is-open');
      li = li.parentElement?.closest('li');
    }
  };

  const setActive = (id) => {
    if (!id || id === lastActiveId) return;
    const a = byId.get(id);
    if (!a) return;
    clearActive();
    a.classList.add('is-active');
    openPathFor(a);
    lastActiveId = id;
  };

  /* Clic TOC → activer de suite et sortir d’un éventuel lock bas de page */
  links.forEach(a => {
    a.addEventListener('click', () => {
      bottomLock = false;
      setActive(decodeURIComponent(a.hash.slice(1)));
    }, { passive: true });
  });

  /* Sentinel de fin d’article (robuste) */
  const article = document.querySelector('.post-content .post-article') || document.querySelector('.post-content');
  let sentinelInView = false;
  if (article) {
    const sentinel = document.createElement('div');
    sentinel.id = 'toc-bottom-sentinel';
    sentinel.setAttribute('aria-hidden', 'true');
    sentinel.style.cssText = 'position:relative;width:1px;height:1px;margin:0;padding:0;';
    article.appendChild(sentinel);

    if ('IntersectionObserver' in window) {
      const bottomIO = new IntersectionObserver((entries) => {
        sentinelInView = !!(entries[0] && entries[0].isIntersecting);
        if (sentinelInView) {
          bottomLock = true;
          setActive(lastHeading.id);
        } else {
          bottomLock = false;
        }
      }, {
        root: null,
        /* seuil strict : on veut être vraiment en bas */
        rootMargin: '0px 0px 0px 0px',
        threshold: 1.0
      });
      bottomIO.observe(sentinel);
    }
  }

  /* Calcul “doux” de la section active :
     - repère haut = topOffsetPx + 8
     - repère milieu = repère haut + 40% de la hauteur de viewport
     On choisit le DERNIER heading dont le haut est <= repère milieu.
     Cela couvre bien les petites sections de fin. */
  const pickBestByMidline = () => {
    const de = document.documentElement;
    const vh = window.innerHeight || de.clientHeight || 800;
    const yTop = topOffsetPx + 8;
    const yMid = yTop + vh * 0.40;

    let best = headings[0];
    for (const h of headings) {
      const r = h.getBoundingClientRect();
      if (r.top <= yMid) best = h; else break;
    }
    return best;
  };

  /* Boucle scroll/resize (throttle via rAF) */
  let ticking = false;
  const onScroll = () => {
    if (ticking) return;
    ticking = true;
    requestAnimationFrame(() => {
      if (!bottomLock && !sentinelInView) {
        const best = pickBestByMidline();
        if (best) setActive(best.id);
      }
      ticking = false;
    });
  };

  window.addEventListener('scroll', onScroll, { passive: true });
  window.addEventListener('resize', onScroll);

  /* État initial (après chargement) */
  requestAnimationFrame(() => {
    if (sentinelInView) {
      bottomLock = true;
      setActive(lastHeading.id);
    } else {
      const best = pickBestByMidline();
      if (best) setActive(best.id);
    }
  });
})();
</script>

<script>
(function () {
  document.querySelectorAll('pre > code').forEach((code) => {
    const pre = code.parentElement;
    if (!pre || pre.classList.contains('has-header')) return;

    // Détection du langage
    const match = (code.className || '').match(/language-([\w+-]+)/i);
    const lang = match ? match[1].toLowerCase() : 'text';

    // Conteneur header
    const header = document.createElement('div');
    header.className = 'code-header';

    // Badge langage
    const badge = document.createElement('span');
    badge.className = 'code-lang';
    badge.textContent = lang;
    header.appendChild(badge);

    // Bouton copier
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'copy-code';
    btn.textContent = 'Copier';
    btn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(code.innerText);
        const old = btn.textContent;
        btn.textContent = 'Copié ✔';
        setTimeout(() => (btn.textContent = old), 1500);
      } catch (e) {
        console.error(e);
        btn.textContent = 'Erreur';
        setTimeout(() => (btn.textContent = 'Copier'), 1500);
      }
    });
    header.appendChild(btn);

    // Positionner le header dans le <pre>
    pre.classList.add('has-header');
    pre.style.position = 'relative';
    pre.insertBefore(header, code);
  });
})();
</script>

{{/* Back to Top — listes (home/section/taxonomy/term) + toutes pages single */}}
{{- $kind := .Kind -}}
{{- $sec  := .Section -}}
{{- $listKinds := slice "home" "section" "taxonomy" "term" "taxonomyTerm" -}}
{{- $isList := in $listKinds $kind -}}
{{- $isSingle := eq .Kind "page" -}}
{{- if or $isList $isSingle -}}
<script>
(function(){
  // éviter la double-injection si partiellement présent ailleurs
  if (document.getElementById('backToTop')) return;

  // 1) Style (injecté une seule fois)
  //if (!document.getElementById('backToTopStyles')){
  //  const css = `
  //    .back-to-top{
  //      position: fixed;
  //      right: 1rem; bottom: 1rem; z-index: 1000;
  //      width: 2.5rem; height: 2.5rem;
  //      border: 1px solid var(--border); border-radius: 999px;
  //      background: var(--theme); color: var(--primary);
  //      font-size: 1.2rem; line-height: 2.5rem; text-align: center;
  //      cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,.12);
  //      transition: transform .2s ease, opacity .2s ease;
  //      opacity: .92;
  //    }
  //    .back-to-top:hover{ transform: translateY(-2px); opacity: 1; }
  //    .back-to-top:active{ transform: translateY(0); }
  //    .back-to-top[hidden]{ display: none !important; }
  //    @media (max-width: 380px){ .back-to-top{ right: .6rem; bottom: .6rem; } }
  //  `;
  //  const st = document.createElement('style');
  //  st.id = 'backToTopStyles';
  //  st.appendChild(document.createTextNode(css));
  //  document.head.appendChild(st);
  //}

  // 2) Création du bouton
  const btn = document.createElement('button');
  btn.id = 'backToTop';
  btn.type = 'button';
  btn.className = 'back-to-top';
  btn.setAttribute('aria-label', 'Revenir en haut');
  btn.title = 'Revenir en haut';
  btn.textContent = '↑';
  btn.hidden = true;
  document.body.appendChild(btn);

  // 3) Comportement au clic (respecte prefers-reduced-motion)
  btn.addEventListener('click', function(){
    const reduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const opt = reduced ? { top: 0 } : { top: 0, behavior: 'smooth' };
    window.scrollTo(opt);
  });
  btn.addEventListener('keyup', function(e){
    if (e.key === 'Enter' || e.key === ' ') btn.click();
  });

  // 4) Affichage conditionnel (seuil d’apparition)
  const THRESHOLD = 100; // ajuste à window.innerHeight si tu préfères
  let ticking = false;

  function toggle(){
    const y = window.pageYOffset || document.documentElement.scrollTop;
    const show = y > THRESHOLD;
    if (show && btn.hasAttribute('hidden')) btn.removeAttribute('hidden');
    else if (!show && !btn.hasAttribute('hidden')) btn.setAttribute('hidden','');
  }

  window.addEventListener('scroll', function(){
    if (!ticking){
      window.requestAnimationFrame(function(){ toggle(); ticking = false; });
      ticking = true;
    }
  }, { passive: true });

  // État initial
  toggle();
})();
</script>

{{- end -}}

