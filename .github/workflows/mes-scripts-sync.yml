name: Sync mes-scripts (changed-only, no prune, scope aware)

on:
  repository_dispatch:
    types: [mes-scripts-release]
  workflow_dispatch:
    inputs:
      scope:
        description: "Scope override (auto from payload, all=regenerate all, none=skip, list=comma list)"
        type: choice
        default: auto
        options:
          - auto
          - all
          - none
          - list
      scripts:
        description: "Comma-separated list (only if scope=list)"
        required: false
        type: string

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout site
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Load payload
        id: payload
        shell: bash
        run: |
          echo '--- client_payload (truncated) ---'
          cat > payload.json <<'JSON'
          ${{ toJson(github.event.client_payload) }}
          JSON
          jq -c '{source_repo,release_tag,scripts}' payload.json || true
          echo '----------------------------------'

      - name: Sync mes-scripts content
        uses: actions/github-script@v7
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
          TARGET_BRANCH:  ${{ vars.TARGET_BRANCH }}
          SCOPE: ${{ github.event.inputs.scope || 'auto' }}
          SCRIPTS_INPUT: ${{ github.event.inputs.scripts || '' }}
        with:
          script: |
            const fs = require('fs');
            const payload = fs.existsSync('payload.json') 
              ? JSON.parse(fs.readFileSync('payload.json', 'utf8')) 
              : { scripts: [], assets: {}, source_repo: "NoelNac-HackEthical/mes-scripts" };

            // ---- Scope management ----
            let scope = process.env.SCOPE || "auto";
            let scripts = new Set(payload.scripts || []);
            const assetsMap = payload.assets || {};
            const allScripts = Object.keys(assetsMap);

            if (scope === "none") {
              core.info("Scope=none → nothing to upsert.");
              return;
            }
            if (scope === "all") {
              scripts = new Set(allScripts);
            }
            if (scope === "list") {
              const raw = (process.env.SCRIPTS_INPUT || "").split(",");
              scripts = new Set();
              raw.forEach(r => {
                const s = r.trim();
                if (s && allScripts.includes(s)) scripts.add(s);
                else if (s) core.warning(`Script '${s}' not found in payload.assets`);
              });
            }
            // default = auto → keep payload.scripts as-is

            if (scripts.size === 0) {
              core.info("No scripts selected for update.");
              return;
            }

            const owner  = context.repo.owner;
            const repo   = context.repo.repo;
            const branch = (process.env.TARGET_BRANCH && process.env.TARGET_BRANCH.trim()) || process.env.DEFAULT_BRANCH || "main";
            const basePath = "content/mes-scripts";
            const sourceRepo = payload.source_repo || "NoelNac-HackEthical/mes-scripts";

            function oneLine(str) {
              if (!str) return "";
              const first = String(str).split(/\r?\n/).find(l => l.trim().length > 0) || "";
              return first.trim();
            }
            function cleanVer(v) {
              if (!v) return "unknown";
              const m = String(v).match(/v?\d+(?:\.\d+){1,3}/i);
              return m ? (m[0].startsWith("v") ? m[0] : "v" + m[0]) : String(v);
            }
            function escapePipes(s){ return String(s || "").replace(/\|/g," "); }

            function buildMarkdown(scriptName, meta) {
              const verRaw = String((meta && meta.version) ? meta.version : "unknown").trim();
              const desc   = oneLine(meta && meta.description ? meta.description : "");
              const usage  = String((meta && meta.usage) ? meta.usage : "").trim();

              let out = "";
              out += "---\n";
              out += `title: "${scriptName.replace(/"/g, '\\"')}"\n`;
              out += `slug: "${scriptName.replace(/"/g, '\\"')}"\n`;
              out += "draft: false\n";
              out += "---\n\n";

              if (desc) {
                out += `> ${desc}\n\n`;
                out += "<!--more-->\n\n";
              }

              out += "## Présentation\n";
              out += "Présentation et fonctionnement de ce script.\n\n";

              out += "## Usage\n";
              out += "`" + verRaw.replace(/`/g, "\\`") + "`\n\n";
              if (usage) out += "```text\n" + usage + "\n```\n\n";

              const latestBase = "https://github.com/" + sourceRepo + "/releases/latest/download/";
              const fileEnc = encodeURIComponent(scriptName);
              const hashEnc = encodeURIComponent(scriptName + ".sha256");

              out += "## Télécharger\n\n";
              out += '<div class="dl-row">\n';
              out += `{{< btn href="${latestBase}${fileEnc}" text="Télécharger la version courante" class="he-btn--neutral" >}}\n`;
              out += `{{< btn href="${latestBase}${hashEnc}" text="SHA256" class="he-btn--sm he-btn--neutral" >}}\n`;
              out += "</div>\n\n";

              return out;
            }

            async function upsertOne(path, content, message) {
              let sha = null;
              try {
                const res = await github.rest.repos.getContent({ owner, repo, path, ref: branch });
                if (!Array.isArray(res.data)) sha = res.data.sha || null;
              } catch (e) {}
              const b64 = Buffer.from(content, "utf8").toString("base64");
              const res = await github.rest.repos.createOrUpdateFileContents({
                owner, repo, path, message, content: b64, branch, sha: sha || undefined,
              });
              return res.data.commit && res.data.commit.sha;
            }

            let count = 0;
            for (const s of scripts) {
              const path = `${basePath}/${s}/index.md`;
              const md   = buildMarkdown(s, assetsMap[s] || {});
              const msg  = `Sync mes-scripts (upsert) ${path}`;
              const sha  = await upsertOne(path, md, msg);
              core.info((sha ? "[UPSERTED] " : "[CREATED] ") + path);
              count++;
            }

            // Update _index.md
            const all = Object.keys(assetsMap).sort();
            let lines = [];
            lines.push("---");
            lines.push('title: "Mes scripts"');
            lines.push('slug: "mes-scripts"');
            lines.push("draft: false");
            lines.push("---");
            lines.push("");
            lines.push("Liste des scripts publiés. Cliquez un script pour voir l’aide détaillée.");
            lines.push("");
            lines.push("| Script | Version | Description |");
            lines.push("|-------:|:--------|:------------|");

            for (const s of all) {
              const meta = assetsMap[s] || {};
              const ver  = cleanVer(meta.version || "unknown");
              let desc   = escapePipes(oneLine(meta.description || ""));
              if (desc.length > 140) desc = desc.slice(0, 137) + "…";
              const link = "[`" + s + "`](/mes-scripts/" + encodeURIComponent(s) + "/)";
              lines.push("| " + link + " | `" + ver + "` | " + (desc ? desc : "") + " |");
            }

            const sectionMd = lines.join("\n");
            await upsertOne(basePath + "/_index.md", sectionMd, "Sync mes-scripts (upsert) " + basePath + "/_index.md");

            core.info(`Sync terminé sur ${branch} — ${count} script(s) upsert + section _index.md mise à jour.`);

      - name: Verify committed files (optional)
        shell: bash
        env:
          TARGET_BRANCH:  ${{ vars.TARGET_BRANCH }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        run: |
          BRANCH="${TARGET_BRANCH:-$DEFAULT_BRANCH}"
          git fetch --all --prune
          git checkout "$BRANCH"
          echo "--- branch: $BRANCH"
          echo '--- tree under content/mes-scripts ---'
          ls -R content/mes-scripts || true
          echo '--------------------------------------'
