name: Sync mes-scripts (changed-only, no prune)

on:
  repository_dispatch:
    types: [mes-scripts-release]

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout site
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Payload preview (optional)
        shell: bash
        run: |
          echo '--- client_payload (truncated) ---'
          cat > payload.json <<'JSON'
          ${{ toJson(github.event.client_payload) }}
          JSON
          jq -c '{source_repo,release_tag,scripts}' payload.json
          echo '----------------------------------'

      - name: Sync mes-scripts content (no prune, per-file upsert)
        uses: actions/github-script@v7
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        with:
          script: |
            const fs = require('fs');
            const payload = JSON.parse(fs.readFileSync('payload.json', 'utf8'));

            const changed = new Set(payload.scripts || []);
            if (changed.size === 0) {
              core.info('No changed scripts in payload → nothing to upsert.');
              return;
            }

            const owner  = context.repo.owner;
            const repo   = context.repo.repo;
            const branch = process.env.DEFAULT_BRANCH || 'main';
            const basePath = 'content/mes-scripts';
            const assetsMap = payload.assets || {};

            // Générateur Markdown (vraies nouvelles lignes)
            function buildMarkdown(scriptName, meta) {
              var ver   = String((meta && meta.version) ? meta.version : 'unknown');
              var desc  = String((meta && meta.description) ? meta.description : '').trim();
              var usage = String((meta && meta.usage) ? meta.usage : '').trim();

              var out = '';
              out += '---\n';
              out += 'title: "' + scriptName.replace(/"/g, '\\"') + '"\n';
              out += 'slug: "' + scriptName.replace(/"/g, '\\"') + '"\n';
              out += 'draft: false\n';
              out += '---\n\n';
              out += '## Version\n';
              out += '`' + ver.replace(/`/g, '\\`') + '`\n\n';
              if (desc) out += '> ' + desc + '\n\n';
              if (usage) out += '```text\n' + usage + '\n```\n\n';
              return out;
            }

            async function upsertOne(path, content, message) {
              // Tenter de récupérer le SHA existant
              let sha = null;
              try {
                const res = await github.rest.repos.getContent({ owner, repo, path, ref: branch });
                if (!Array.isArray(res.data)) sha = res.data.sha || null;
              } catch (e) {
                // not found -> sha = null
              }

              const b64 = Buffer.from(content, 'utf8').toString('base64');

              const res = await github.rest.repos.createOrUpdateFileContents({
                owner, repo, path,
                message,
                content: b64,
                branch,
                sha: sha || undefined,
              });

              return res.data.commit && res.data.commit.sha;
            }

            let count = 0;
            for (const s of changed) {
              const path = basePath + '/' + s + '/index.md';
              const md   = buildMarkdown(s, assetsMap[s] || {});
              const msg  = 'Sync mes-scripts (upsert) ' + path;
              const sha  = await upsertOne(path, md, msg);
              core.info((sha ? '[UPSERTED] ' : '[CREATED] ') + path);
              count++;
            }

            core.info('Sync terminé sur ' + branch + ' — ' + count + ' script(s) upsert.');

      - name: Verify committed files (optional)
        shell: bash
        run: |
          git fetch --all --prune
          git checkout ${{ github.event.repository.default_branch }}
          echo '--- tree under content/mes-scripts ---'
          ls -R content/mes-scripts || true
          echo '--------------------------------------'
