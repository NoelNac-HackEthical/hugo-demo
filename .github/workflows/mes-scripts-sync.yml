name: Sync mes-scripts (changed-only, no prune) version master

on:
  repository_dispatch:
    types: [mes-scripts-release]

permissions:
  contents: write
  pull-requests: read

jobs:
  sync:
    runs-on: ubuntu-latest

    env:
      TARGET_BRANCH: ${{ vars.TARGET_BRANCH }}
      DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}

    steps:
      - name: Checkout site
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve TARGET_BRANCH → BRANCH (fallback to default)
        shell: bash
        run: |
          set -euo pipefail
          TB="${TARGET_BRANCH:-}"
          DB="${DEFAULT_BRANCH:-master}"
          BR="${TB:-$DB}"
          echo "TARGET_BRANCH='${TB:-<empty>}'  DEFAULT_BRANCH='$DB'  → BRANCH='$BR'"
          echo "BRANCH=$BR" >> "$GITHUB_ENV"

      - name: Decide target branch & reset from default
        shell: bash
        run: |
          set -euo pipefail
          BRANCH="${TARGET_BRANCH:-$DEFAULT_BRANCH}"

          git fetch --all --prune
          git checkout -B "$BRANCH" "origin/${DEFAULT_BRANCH}"

          echo "BRANCH=$BRANCH" >> $GITHUB_ENV
          echo "--- branch reset to origin/${DEFAULT_BRANCH} as $BRANCH"

      - name: Payload preview (optional)
        shell: bash
        run: |
          echo '--- client_payload (truncated) ---'
          cat > payload.json <<'JSON'
          ${{ toJson(github.event.client_payload) }}
          JSON
          jq -c '{scope, scripts, assets:(.assets|keys|length)}' payload.json || cat payload.json
          echo '----------------------------------'

      - name: Sync mes-scripts content (no prune, per-file upsert)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const payload = JSON.parse(fs.readFileSync('payload.json', 'utf8'));

            const owner  = context.repo.owner;
            const repo   = context.repo.repo;
            const branch = process.env.BRANCH || process.env.DEFAULT_BRANCH || 'master';

            const basePath  = 'content/mes-scripts';
            const assetsMap = payload.assets || {};
            const changed   = new Set(payload.scripts || []);

            // Humanize: "mon-nmap" -> "Mon Nmap"; "make_htb" -> "Make Htb"
            function humanizeTitle(s) {
              return String(s)
                .replace(/[-_]+/g, ' ')
                .split(' ')
                .map(w => w ? (w[0].toUpperCase() + w.slice(1)) : w)
                .join(' ');
            }

            // Front matter + sections selon ta demande
            function buildMarkdown(scriptName, meta) {
              const ver   = String((meta && meta.version) || '# VERSION');
              const desc  = String((meta && meta.description) || 'Résumé court de l\'outil.');
              const usage = String((meta && meta.usage) || '').trim();

              const title = humanizeTitle(scriptName);
              const slug  = scriptName; // conservé tel quel

              let out = '';
              // --- FRONT MATTER EXACT ---
              out += '---\n';
              out += `title: "${title.replace(/"/g, '\\"')}"\n`;
              out += `slug: "${slug.replace(/"/g, '\\"')}"\n`;
              out += `description: "${desc.replace(/"/g, '\\"')}"\n`;
              out += 'draft: false\n';
              out += 'tags: ["scripts","tools"]\n';
              out += 'categories: ["Mes scripts"]\n';
              out += 'showIntro: false\n';
              out += 'cover:\n';
              out += '  hidden: true\n';
              out += '  hiddenInSingle: true\n';
              out += `repo: "${owner}/mes-scripts"\n`; // ex: "NoelNac-HackEthical/mes-scripts"
              out += '---\n\n';
              // --------------------------

              // Corps du document
              out += '## Présentation\n';
              out += `Présentation de mon script (${scriptName}).\n\n`;

              out += '## Usage\n';
              if (usage) {
                out += '```text\n' + usage + '\n```\n\n';
              } else {
                out += '_Aucun exemple d\'usage fourni pour l\'instant._\n\n';
              }

              const dlBase  = `https://github.com/${owner}/mes-scripts/releases/latest/download/${scriptName}`;
              out += '## Téléchargements\n\n';
              out += `La version courante du script est \`${ver}\`.\n\n`;
              out += '<div class="dl-row">\n';
              out += `  {{< btn href="${dlBase}" text="Télécharger la version courante" class="he-btn--neutral" >}}\n`;
              out += `  {{< btn href="${dlBase}.sha256" text="SHA256" class="he-btn--sm he-btn--neutral" >}}\n`;
              out += '</div>\n\n';

              return out;
            }

            async function getShaIfExists(path) {
              try {
                const { data } = await github.rest.repos.getContent({ owner, repo, path, ref: branch });
                return Array.isArray(data) ? null : (data.sha || null);
              } catch {
                return null; // not found
              }
            }

            async function upsertFile(path, content, message) {
              const sha = await getShaIfExists(path);
              const b64 = Buffer.from(content, 'utf8').toString('base64');

              await github.rest.repos.createOrUpdateFileContents({
                owner, repo, path,
                branch,
                message,
                content: b64,
                sha: sha || undefined
              });

              core.info((sha ? '[UPSERTED] ' : '[CREATED] ') + path);
            }

            if (changed.size === 0) {
              core.info('No scripts provided in payload → nothing to upsert.');
              return;
            }

            // Upsert des scripts demandés
            let count = 0;
            for (const s of changed) {
              const md   = buildMarkdown(s, assetsMap[s] || {});
              const path = `${basePath}/${s}/index.md`;
              const msg  = `Sync mes-scripts (upsert) ${path}`;
              await upsertFile(path, md, msg);
              count++;
            }

            // Regénération de la page liste
            const scriptsAll = Object.keys(assetsMap).sort();
            let list = '';
            list += '---\n';
            list += 'title: "Mes scripts"\n';
            list += 'slug: "mes-scripts"\n';
            list += 'draft: false\n';
            list += '---\n\n';
            list += 'Liste des scripts publiés. Cliquez un script pour voir l’aide détaillée.\n\n';
            list += '| Script | Version | Description |\n';
            list += '|-------:|:--------|:------------|\n';
            for (const s of scriptsAll) {
              const meta = assetsMap[s] || {};
              const ver  = String(meta.version || 'unknown');
              const d    = String(meta.description || '').trim();
              list += `| \`${s}\` | \`${ver}\` | ${d ? d : ''} |\n`;
            }
            await upsertFile(`${basePath}/_index.md`, list, 'Sync mes-scripts (update list)');

            core.info(`Sync terminé sur ${branch} — ${count} script(s) upsert + section _index.md mise à jour.`);

      - name: Cleanup temp files
        shell: bash
        run: |
          rm -f payload.json || true

      # ⚠️ NOTE :
      # L'étape ci-dessous pousse depuis le checkout local.
      # Comme on commit déjà via l'API (createOrUpdateFileContents), il peut ne rien y avoir à pousser.
      # Si tu constates que cela écrase les commits API, remplace cette étape par un simple "verify remote tip".
      - name: Push branch (robuste)
        shell: bash
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          BRANCH="${BRANCH:-${TARGET_BRANCH:-$DEFAULT_BRANCH}}"

          git add -A
          if git diff --quiet --cached; then
            echo "No changes to commit."
          else
            git commit -m "Sync mes-scripts (rebased on ${DEFAULT_BRANCH})"
          fi

          git fetch origin "$BRANCH" --prune

          if git push --force-with-lease origin "$BRANCH"; then
            echo "Pushed with --force-with-lease."
          else
            echo "with-lease rejected → retrying with --force…"
            git push --force origin "$BRANCH"
          fi

      - name: Verify committed files (optional)
        shell: bash
        run: |
          set -euo pipefail
          echo "--- branch: ${BRANCH}"
          ls -R content/mes-scripts || true
