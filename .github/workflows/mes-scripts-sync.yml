name: Sync mes-scripts (changed-only, no prune)

on:
  repository_dispatch:
    types: [mes-scripts-release]

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout site
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Payload preview (optional)
        shell: bash
        run: |
          echo '--- client_payload (truncated) ---'
          cat > payload.json <<'JSON'
          ${{ toJson(github.event.client_payload) }}
          JSON
          jq -c '{source_repo,release_tag,scripts}' payload.json
          echo '----------------------------------'

      - name: Sync mes-scripts content (no prune, per-file upsert)
        uses: actions/github-script@v7
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
          TARGET_BRANCH:  ${{ vars.TARGET_BRANCH }}   # ex: feature/menu-outils-structure
        with:
          script: |
            const fs = require('fs');
            const payload = JSON.parse(fs.readFileSync('payload.json', 'utf8'));

            const changed = new Set(payload.scripts || []);
            if (changed.size === 0) {
              core.info('No changed scripts in payload → nothing to upsert.');
              return;
            }

            const owner  = context.repo.owner;
            const repo   = context.repo.repo;
            const branch = (process.env.TARGET_BRANCH && process.env.TARGET_BRANCH.trim()) || process.env.DEFAULT_BRANCH || 'main';
            const basePath = 'content/mes-scripts';
            const assetsMap = payload.assets || {};

            function oneLine(str) {
              if (!str) return '';
              const first = String(str).split(/\r?\n/).find(l => l.trim().length > 0) || '';
              return first.trim();
            }
            function cleanVer(v) {
              if (!v) return 'unknown';
              const m = String(v).match(/v?\d+(?:\.\d+){1,3}/i);
              return m ? (m[0].startsWith('v') ? m[0] : 'v' + m[0]) : String(v);
            }
            function escapePipes(s){ return String(s || '').replace(/\|/g,' '); }

            // Générateur Markdown (avec section Télécharger)
            function buildMarkdown(scriptName, meta) {
              var verRaw = String((meta && meta.version) ? meta.version : 'unknown').trim();
              var desc   = oneLine((meta && meta.description) ? meta.description : '');
              var usage  = String((meta && meta.usage) ? meta.usage : '').trim();

              var out = '';
              out += '---\n';
              out += 'title: "' + scriptName.replace(/"/g, '\\"') + '"\n';
              out += 'slug: "' + scriptName.replace(/"/g, '\\"') + '"\n';
              out += 'draft: false\n';
              out += '---\n\n';

              if (desc) {
                out += '> ' + desc + '\n\n';
                out += '<!--more-->\n\n';
              }

              out += '## Version\n';
              out += '`' + verRaw.replace(/`/g, '\\`') + '`\n\n';

              if (usage) out += '```text\n' + usage + '\n```\n\n';

              // Section Télécharger le script
              if (meta && meta.url) {
                out += '## Télécharger le script\n\n';
                out += `- [Télécharger le script](${meta.url})\n`;
                if (meta.sha256) {
                  out += `- [Checksum SHA-256](${meta.sha256})\n`;
                }
                out += '\n';
              }

              return out;
            }

            async function upsertOne(path, content, message) {
              let sha = null;
              try {
                const res = await github.rest.repos.getContent({ owner, repo, path, ref: branch });
                if (!Array.isArray(res.data)) sha = res.data.sha || null;
              } catch (e) { /* not found */ }

              const b64 = Buffer.from(content, 'utf8').toString('base64');

              const res = await github.rest.repos.createOrUpdateFileContents({
                owner, repo, path,
                message,
                content: b64,
                branch,
                sha: sha || undefined,
              });

              return res.data.commit && res.data.commit.sha;
            }

            // 1) Upsert des pages individuelles
            let count = 0;
            for (const s of changed) {
              const path = basePath + '/' + s + '/index.md';
              const md   = buildMarkdown(s, assetsMap[s] || {});
              const msg  = 'Sync mes-scripts (upsert) ' + path;
              const sha  = await upsertOne(path, md, msg);
              core.info((sha ? '[UPSERTED] ' : '[CREATED] ') + path);
              count++;
            }

            // 2) Regénérer _index.md
            const allScripts = Object.keys(assetsMap).sort();
            let lines = [];
            lines.push('---');
            lines.push('title: "Mes scripts"');
            lines.push('slug: "mes-scripts"');
            lines.push('draft: false');
            lines.push('---');
            lines.push('');
            lines.push('Liste des scripts publiés. Cliquez un script pour voir l’aide détaillée.');
            lines.push('');
            lines.push('| Script | Version | Description |');
            lines.push('|-------:|:--------|:------------|');

            for (const s of allScripts) {
              const meta = assetsMap[s] || {};
              const ver  = cleanVer(meta.version || 'unknown');
              let desc   = escapePipes(oneLine(meta.description || ''));
              if (desc.length > 140) desc = desc.slice(0, 137) + '…';

              const link = '[`' + s + '`](/mes-scripts/' + encodeURIComponent(s) + '/)';
              lines.push('| ' + link + ' | `' + ver + '` | ' + (desc ? desc : '') + ' |');
            }

            const sectionMd = lines.join('\n');
            await upsertOne(basePath + '/_index.md', sectionMd, 'Sync mes-scripts (upsert) ' + basePath + '/_index.md');

            core.info('Sync terminé sur ' + branch + ' — ' + count + ' script(s) upsert + section _index.md mise à jour.');

      - name: Verify committed files (optional)
        shell: bash
        env:
          TARGET_BRANCH:  ${{ vars.TARGET_BRANCH }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        run: |
          BRANCH="${TARGET_BRANCH:-$DEFAULT_BRANCH}"
          git fetch --all --prune
          git checkout "$BRANCH"
          echo "--- branch: $BRANCH"
          echo '--- tree under content/mes-scripts ---'
          ls -R content/mes-scripts || true
          echo '--------------------------------------'
