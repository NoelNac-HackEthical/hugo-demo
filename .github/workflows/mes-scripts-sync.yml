name: Sync mes-scripts (changed-only, no prune)

on:
  repository_dispatch:
    types: [mes-scripts-release]

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout site
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Payload preview (optional)
        shell: bash
        run: |
          echo '--- client_payload (truncated) ---'
          jq -c '{source_repo,release_tag,scripts}' <<'JSON'
          ${{ toJson(github.event.client_payload) }}
          JSON
          echo '----------------------------------'

      - name: Sync mes-scripts content (no prune)
        uses: actions/github-script@v7
        env:
          CLIENT_PAYLOAD: ${{ toJson(github.event.client_payload) }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        with:
          script: |
            const payload = JSON.parse(process.env.CLIENT_PAYLOAD || '{}');

            // Scripts modifiés uniquement
            const changed = new Set(payload.scripts || []);
            if (changed.size === 0) {
              core.info('No changed scripts in payload → nothing to upsert.');
              return;
            }

            const owner  = context.repo.owner;
            const repo   = context.repo.repo;
            const branch = process.env.DEFAULT_BRANCH || 'main';
            const basePath = 'content/mes-scripts';
            const assetsMap = payload.assets || {};

            // Helpers GitHub
            async function getRefSha() {
              const { data: ref } = await github.rest.git.getRef({ owner, repo, ref: `heads/${branch}` });
              return ref.object.sha;
            }
            async function getTree(sha) {
              const { data: commit } = await github.rest.git.getCommit({ owner, repo, commit_sha: sha });
              const { data: tree }   = await github.rest.git.getTree({ owner, repo, tree_sha: commit.tree.sha, recursive: true });
              return { commit, tree };
            }
            async function getFileSha(path) {
              try {
                const { data } = await github.rest.repos.getContent({ owner, repo, path, ref: branch });
                if (Array.isArray(data)) return null;
                return data.sha || null;
              } catch { return null; }
            }

            // Générateur Markdown (propre, sans backticks imbriqués)
            function buildMarkdown(scriptName, meta) {
              const ver   = String((meta && meta.version) ?? 'unknown');
              const desc  = String((meta && meta.description) ?? '').trim();
              const usage = String((meta && meta.usage) ?? '').trim();

              const lines = [
                '---',
                `title: "${scriptName}"`,
                `slug: "${scriptName}"`,
                'draft: false',
                '---',
                '',
                '## Version',
                `\\`${ver}\\``,
                ''
              ];
              if (desc) { lines.push(`> ${desc}`, ''); }
              if (usage) { lines.push('```text', usage, '```', ''); }
              return lines.join('\n');
            }

            // 1) Lister pages existantes pour log [KEEP]
            const headSha = await getRefSha();
            const { tree: fullTree } = await getTree(headSha);
            const existing = new Set(
              (fullTree.tree || [])
                .filter(t => t.type === 'blob' && t.path.startsWith(`${basePath}/`) && t.path.endsWith('/index.md'))
                .map(t => t.path.slice(`${basePath}/`.length).split('/')[0])
            );

            // 2) Upsert uniquement les scripts modifiés
            const filesToCommit = [];
            for (const s of changed) {
              const path = `${basePath}/${s}/index.md`;
              const sha  = await getFileSha(path);
              const meta = assetsMap[s] || {};
              const content = buildMarkdown(s, meta);
              core.info(sha ? `[UPSERT] ${path}` : `[CREATE] ${path}`);
              filesToCommit.push({ path, mode: '100644', type: 'blob', content });
            }

            // 3) Les autres restent en place
            for (const s of existing) {
              if (!changed.has(s)) core.info(`[KEEP] ${basePath}/${s}/index.md`);
            }

            if (filesToCommit.length === 0) {
              core.info('Nothing to commit.');
              return;
            }

            // 4) Commit unique (createBlob → createTree → createCommit → updateRef)
            const blobs = [];
            for (const f of filesToCommit) {
              const { data: blob } = await github.rest.git.createBlob({
                owner, repo,
                content: Buffer.from(f.content, 'utf8').toString('base64'),
                encoding: 'base64',
              });
              blobs.push({ path: f.path, mode: f.mode, type: f.type, sha: blob.sha });
            }

            const { data: headCommit } = await github.rest.git.getCommit({ owner, repo, commit_sha: headSha });
            const { data: baseTree }   = await github.rest.git.getTree({ owner, repo, tree_sha: headCommit.tree.sha, recursive: true });
            const newTree = (baseTree.tree || []).filter(e => !blobs.some(b => b.path === e.path));
            newTree.push(...blobs);

            const { data: createdTree } = await github.rest.git.createTree({
              owner, repo,
              base_tree: headCommit.tree.sha,
              tree: newTree.map(e => ({ path: e.path, mode: e.mode || '100644', type: e.type || 'blob', sha: e.sha })),
            });

            const { data: newCommit } = await github.rest.git.createCommit({
              owner, repo,
              message: 'Sync mes-scripts (changed-only, no prune, H2 Version)',
              tree: createdTree.sha,
              parents: [headSha],
            });

            await github.rest.git.updateRef({
              owner, repo,
              ref: `heads/${branch}`,
              sha: newCommit.sha,
              force: false,
            });

            core.info(`Sync terminé sur ${branch} — ${filesToCommit.length} script(s) upsert.`);
