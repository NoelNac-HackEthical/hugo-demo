name: Sync mes-scripts pages (multi-branch, overwrite with static asset links)

on:
  repository_dispatch:
    types: [mes-scripts-release]
  workflow_dispatch:
    inputs:
      target_branch:
        description: "Branche d'écriture (optionnel, sinon TARGET_BRANCH ou default)"
        required: false
        default: ""

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest

    env:
      # Définir TARGET_BRANCH dans: Settings → Security → Secrets and variables → Actions → Variables
      # ex: feature/menu-outils-structure
      TARGET_BRANCH: ${{ vars.TARGET_BRANCH }}

    steps:
      - name: Compute target branch
        id: branch
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            const inputBranch = (core.getInput('target_branch') || '').trim();
            const varBranch   = (process.env.TARGET_BRANCH || '').trim();

            const repoInfo = await github.rest.repos.get({ owner, repo });
            const defaultBranch = repoInfo.data.default_branch || 'master';

            const targetBranch = inputBranch || varBranch || defaultBranch;
            core.setOutput('target', targetBranch);
            core.info(`Target branch: ${targetBranch}`);

      - name: Overwrite bundles from payload (no checkout)
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const targetBranch = '${{ steps.branch.outputs.target }}';

<<<<<<< Updated upstream
            // Payload
=======
            // Payload reçu
>>>>>>> Stashed changes
            const payload = context.payload.client_payload || {};
            const scripts = Array.isArray(payload.scripts) ? payload.scripts : [];
            const assets  = payload.assets || {};                // { script: {url, sha256, version} }
            const tag     = payload.release_tag || "unknown-tag";

            if (context.eventName !== 'workflow_dispatch' && scripts.length === 0) {
              core.warning("Payload.scripts est vide — rien à synchroniser.");
              return;
            }

            // Helpers ---------------------------------------------------------
            async function getRefSha(branch) {
              const res = await github.rest.git.getRef({ owner, repo, ref: `heads/${branch}` }).catch(() => null);
              return res?.data?.object?.sha || null;
            }
            async function getFileSha(path) {
              try {
                const res = await github.rest.repos.getContent({ owner, repo, path, ref: targetBranch });
                if (Array.isArray(res.data)) return null;
                return res.data.sha || null;
              } catch { return null; }
            }
            async function upsertFile(path, content, message) {
              const sha = await getFileSha(path);
              const encoded = Buffer.from(content, "utf8").toString("base64");
              await github.rest.repos.createOrUpdateFileContents({
                owner, repo, path, message, content: encoded,
                sha: sha || undefined, branch: targetBranch
              });
            }
            async function deleteFile(path, message) {
              const res = await github.rest.repos.getContent({ owner, repo, path, ref: targetBranch }).catch(() => null);
              const sha = res && !Array.isArray(res.data) ? res.data.sha : null;
              if (!sha) return;
              await github.rest.repos.deleteFile({ owner, repo, path, message, sha, branch: targetBranch });
            }

<<<<<<< Updated upstream
            // Template index.md (liens statiques + version script)
            function renderIndexMinimal(name, assetsMap, tag) {
              const a = assetsMap && assetsMap[name] ? assetsMap[name] : {};
              const url = a.url || `https://github.com/NoelNac-HackEthical/mes-scripts/releases/latest`;
              const sha = a.sha256 || "";
              const ver = a.version || "unknown";

              return [
                '---',
                `title: "${name}"`,
                `description: "Script ${name} (généré automatiquement)."`,
                'draft: false',
                '---',
                '',
                '## Télécharger',
                '',
                `**Version du script :** \`${ver}\`  `,
                (sha
                  ? `[⬇ Télécharger ${name}](${url}) &nbsp;|&nbsp; [SHA256](${sha})`
                  : `[⬇ Télécharger ${name}](${url})`
                ),
                '',
                '> Cette page est générée automatiquement à partir de la dernière release de **mes-scripts**.',
                ''
              ].join('\n');
=======
            // Template index.md (liens latest + bouton CSS + lien vers le repo)
            function renderIndexMinimal(name, assetsMap, tag) {
              const a   = assetsMap && assetsMap[name] ? assetsMap[name] : {};
              const ver = a.version || "unknown";

              const owner = "NoelNac-HackEthical";
              const repo  = "mes-scripts";
              const latestBase = `https://github.com/${owner}/${repo}/releases/latest/download`;
              const latestUrl  = `${latestBase}/${name}`;
              const latestSha  = `${latestBase}/${name}.sha256`;
              const repoUrl    = `https://github.com/${owner}/${repo}`;

              return [
                "---",
                `title: "${name}"`,
                `description: "Script ${name} (généré automatiquement)."`,
                "draft: false",
                "---",
                "",
                "## Télécharger le script",
                "",
                `<p class="version-line">`,
                `  La version courante du script est <code>${ver}</code>`,
                `</p>`,
                "",
                `<div class="dl-row">`,
                `  <a href="${latestUrl}" class="he-btn he-btn--neutral">Télécharger la version courante</a>`,
                `  <a href="${latestSha}" class="he-btn he-btn--sm he-btn--neutral">SHA256</a>`,
                `</div>`,
                "",
                `<p><a href="${repoUrl}">Voir le dépôt mes-scripts sur GitHub</a></p>`,
                "",
                "> Cette page est générée automatiquement à partir des releases de **mes-scripts** (liens par défaut vers `latest`).",
                ""
              ].join("\n");
>>>>>>> Stashed changes
            }

            // 1) Vérifier la branche cible
            const targetSha = await getRefSha(targetBranch);
            if (!targetSha) {
              core.setFailed(`Branche cible introuvable: ${targetBranch}`);
              return;
            }

            // 2) Lister les index.md existants
            const tree = await github.rest.git.getTree({ owner, repo, tree_sha: targetSha, recursive: "1" });
            const existingFiles = new Set();
            for (const item of tree.data.tree) {
              if (item.type === "blob" && item.path.startsWith("content/mes-scripts/") && item.path.endsWith("/index.md")) {
                existingFiles.add(item.path);
              }
            }

            // 3) Exécution manuelle sans payload -> log et stop
            if (scripts.length === 0) {
              core.info(`Aucun script dans le payload. Test manuel OK sur ${targetBranch}.`);
              return;
            }

            // 4) Écrire/écraser les pages
            for (const s of scripts) {
              const path = `content/mes-scripts/${s}/index.md`;
              const body = renderIndexMinimal(s, assets, tag);
              const msg  = `chore(mes-scripts): overwrite ${path} from ${tag} [branch=${targetBranch}]`;
              await upsertFile(path, body, msg);
              core.info(`[UPSERT] ${path}`);
            }

            // 5) Supprimer ce qui n'est plus listé
            const desiredSet = new Set(scripts);
            const toDelete = [...existingFiles].filter(p => {
              const parts = p.split('/');
              const scriptName = parts[2];
              return !desiredSet.has(scriptName);
            });
            for (const path of toDelete) {
              const msg = `chore(mes-scripts): remove ${path} (not in ${tag}) [branch=${targetBranch}]`;
              await deleteFile(path, msg);
              core.info(`[DELETE] ${path}`);
            }

            core.info(`Sync terminé sur ${targetBranch} — ${scripts.length} script(s).`);
