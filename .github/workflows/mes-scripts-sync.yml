name: Sync mes-scripts (changed-only, no prune)

on:
  repository_dispatch:
    types: [mes-scripts-release]

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout site
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Payload preview (optional)
        shell: bash
        run: |
          echo '--- client_payload (truncated) ---'
          cat > payload.json <<'JSON'
          ${{ toJson(github.event.client_payload) }}
          JSON
          jq -c '{source_repo,release_tag,scripts}' payload.json
          echo '----------------------------------'

      - name: Sync mes-scripts content (no prune)
        uses: actions/github-script@v7
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        with:
          script: |
            const fs = require('fs');

            // Lire le payload JSON écrit par l'étape précédente
            const payload = JSON.parse(fs.readFileSync('payload.json', 'utf8'));

            // Scripts modifiés uniquement
            const changedArr = payload.scripts || [];
            const changed = new Set(changedArr);
            if (changed.size === 0) {
              core.info('No changed scripts in payload → nothing to upsert.');
              return;
            }

            const owner  = context.repo.owner;
            const repo   = context.repo.repo;
            const branch = process.env.DEFAULT_BRANCH || 'main';
            const basePath = 'content/mes-scripts';
            const assetsMap = payload.assets || {};

            // Helpers GitHub (pas de template literals)
            async function getRefSha() {
              const res = await github.rest.git.getRef({ owner: owner, repo: repo, ref: 'heads/' + branch });
              return res.data.object.sha;
            }
            async function getTree(sha) {
              const commit = await github.rest.git.getCommit({ owner: owner, repo: repo, commit_sha: sha });
              const tree   = await github.rest.git.getTree({ owner: owner, repo: repo, tree_sha: commit.data.tree.sha, recursive: true });
              return { commit: commit.data, tree: tree.data };
            }
            async function getFileSha(path) {
              try {
                const res = await github.rest.repos.getContent({ owner: owner, repo: repo, path: path, ref: branch });
                if (Array.isArray(res.data)) return null;
                return res.data.sha || null;
              } catch (e) { return null; }
            }

            // Générateur Markdown (vraies nouvelles lignes "\n")
            function buildMarkdown(scriptName, meta) {
              var ver   = String((meta && meta.version) ? meta.version : 'unknown');
              var desc  = String((meta && meta.description) ? meta.description : '').trim();
              var usage = String((meta && meta.usage) ? meta.usage : '').trim();

              var out = '';
              out += '---\n';
              out += 'title: "' + scriptName.replace(/"/g, '\\"') + '"\n';
              out += 'slug: "' + scriptName.replace(/"/g, '\\"') + '"\n';
              out += 'draft: false\n';
              out += '---\n\n';
              out += '## Version\n';
              out += '`' + ver.replace(/`/g, '\\`') + '`\n\n';
              if (desc) {
                out += '> ' + desc + '\n\n';
              }
              if (usage) {
                out += '```text\n' + usage + '\n```\n\n';
              }
              return out;
            }

            // 1) Pages existantes (log [KEEP])
            const headSha = await getRefSha();
            const fullTree = (await getTree(headSha)).tree;
            const existing = new Set(
              (fullTree.tree || [])
                .filter(function(t){ return t.type === 'blob' && t.path.indexOf(basePath + '/') === 0 && t.path.endsWith('/index.md'); })
                .map(function(t){ return t.path.slice((basePath + '/').length).split('/')[0]; })
            );

            // 2) Upsert scripts modifiés
            const filesToCommit = [];
            for (const s of changed) {
              const path = basePath + '/' + s + '/index.md';
              const sha  = await getFileSha(path);
              const meta = assetsMap[s] || {};
              const content = buildMarkdown(s, meta);
              core.info((sha ? '[UPSERT] ' : '[CREATE] ') + path);
              filesToCommit.push({ path: path, mode: '100644', type: 'blob', content: content });
            }

            // 3) Autres en [KEEP]
            for (const s of existing) {
              if (!changed.has(s)) core.info('[KEEP] ' + basePath + '/' + s + '/index.md');
            }

            if (filesToCommit.length === 0) {
              core.info('Nothing to commit.');
              return;
            }

            // 4) Commit unique (createBlob → createTree → createCommit → updateRef)
            const blobs = [];
            for (const f of filesToCommit) {
              const blob = await github.rest.git.createBlob({
                owner: owner, repo: repo,
                content: Buffer.from(f.content, 'utf8').toString('base64'),
                encoding: 'base64',
              });
              blobs.push({ path: f.path, mode: f.mode, type: f.type, sha: blob.data.sha });
            }

            const headCommit = await github.rest.git.getCommit({ owner: owner, repo: repo, commit_sha: headSha });
            const baseTree   = await github.rest.git.getTree({ owner: owner, repo: repo, tree_sha: headCommit.data.tree.sha, recursive: true });

            const newTree = (baseTree.data.tree || []).filter(function(e){
              return !blobs.some(function(b){ return b.path === e.path; });
            });
            Array.prototype.push.apply(newTree, blobs);

            const createdTree = await github.rest.git.createTree({
              owner: owner, repo: repo,
              base_tree: headCommit.data.tree.sha,
              tree: newTree.map(function(e){ return { path: e.path, mode: e.mode || '100644', type: e.type || 'blob', sha: e.sha }; }),
            });

            const newCommit = await github.rest.git.createCommit({
              owner: owner, repo: repo,
              message: 'Sync mes-scripts (changed-only, no prune, H2 Version)',
              tree: createdTree.data.sha,
              parents: [headSha],
            });

            await github.rest.git.updateRef({
              owner: owner, repo: repo,
              ref: 'heads/' + branch,
              sha: newCommit.data.sha,
              force: false,
            });

            core.info('Sync terminé sur ' + branch + ' — ' + filesToCommit.length + ' script(s) upsert.');
