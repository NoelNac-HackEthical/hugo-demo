name: Sync mes-scripts (changed-only, no prune) version master

on:
  repository_dispatch:
    types: [mes-scripts-release]

permissions:
  contents: write
  pull-requests: read

jobs:
  sync:
    runs-on: ubuntu-latest

    env:
      TARGET_BRANCH: ${{ vars.TARGET_BRANCH }}
      DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}

    steps:
      - name: Checkout site
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve TARGET_BRANCH → BRANCH (fallback to default)
        shell: bash
        run: |
          set -euo pipefail
          TB="${TARGET_BRANCH:-}"
          DB="${DEFAULT_BRANCH:-master}"
          BR="${TB:-$DB}"
          echo "TARGET_BRANCH='${TB:-<empty>}'  DEFAULT_BRANCH='$DB'  → BRANCH='$BR'"
          echo "BRANCH=$BR" >> "$GITHUB_ENV"

      - name: Decide target branch & reset from default
        shell: bash
        run: |
          set -euo pipefail
          BRANCH="${TARGET_BRANCH:-$DEFAULT_BRANCH}"

          git fetch --all --prune
          git checkout -B "$BRANCH" "origin/${DEFAULT_BRANCH}"

          echo "BRANCH=$BRANCH" >> $GITHUB_ENV
          echo "--- branch reset to origin/${DEFAULT_BRANCH} as $BRANCH"

      - name: Payload preview (optional)
        shell: bash
        run: |
          echo '--- client_payload (truncated) ---'
          cat > payload.json <<'JSON'
          ${{ toJson(github.event.client_payload) }}
          JSON
          jq -c '{scope, scripts, assets:(.assets|keys|length)}' payload.json || cat payload.json
          echo '----------------------------------'

      - name: Sync mes-scripts content (no prune, per-file upsert)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
        # IMPORTANT: bloc JS ci-dessous — pas d'apostrophes non échappées dans les strings entre '...'
          script: |
            const fs = require('fs');
            const payload = JSON.parse(fs.readFileSync('payload.json', 'utf8'));

            const owner  = context.repo.owner;
            const repo   = context.repo.repo;
            const branch = process.env.BRANCH || process.env.DEFAULT_BRANCH || 'master';

            const basePath  = 'content/mes-scripts';
            const assetsMap = payload.assets || {};
            const changed   = new Set(payload.scripts || []);

            // Humanize: "mon-nmap" -> "Mon Nmap"; "make_htb" -> "Make Htb"
            function humanizeTitle(s) {
              return String(s)
                .replace(/[-_]+/g, ' ')
                .split(' ')
                .map(w => (w ? (w[0].toUpperCase() + w.slice(1)) : w))
                .join(' ');
            }

            // FRONT MATTER + contenu, avec ligne initiale (desc) avant ## Présentation
            function buildMarkdown(scriptName, meta) {
              const ver   = String((meta && meta.version) || '# VERSION');
              const desc  = String((meta && meta.description) || "Résumé court de l'outil.").trim();
              const usage = String((meta && meta.usage) || '').trim();

              const title    = humanizeTitle(scriptName);
              const slug     = scriptName; // conservé tel quel
              const repoSlug = "NoelNac-HackEthical/mes-scripts"; // explicitement demandé

              let out = '';
              // --- FRONT MATTER EXACT ---
              out += '---\n';
              out += `title: "${title.replace(/"/g, '\\"')}"\n`;
              out += `slug: "${slug.replace(/"/g, '\\"')}"\n`;
              out += `description: "${desc.replace(/"/g, '\\"')}"\n`;
              out += 'draft: false\n';
              out += 'tags: ["scripts","tools"]\n';
              out += 'categories: ["Mes scripts"]\n';
              out += 'showIntro: false\n';
              out += 'cover:\n';
              out += '  hidden: true\n';
              out += '  hiddenInSingle: true\n';
              out += `repo: "${repoSlug}"\n`;
              out += '---\n\n';
              // --------------------------

              // Ligne initiale visible (issue de # DESCRIPTION)
              if (desc) {
                out += `${desc}\n\n`;
              }

              // Corps du document
              out += '## Présentation\n';
              out += `Présentation de mon script (${scriptName}).\n\n`;

              out += '## Usage\n';
              if (usage) {
                out += '```text\n' + usage + '\n```\n\n';
              } else {
                // UTILISER DES GUILLEMETS DOUBLES ICI pour éviter les conflits d'apostrophes
                out += " _Aucun exemple d'usage fourni pour l'instant._\n\n";
              }

              const dlBase  = `https://github.com/${repoSlug}/releases/latest/download/${scriptName}`;
              out += '## Téléchargements\n\n';
              out += `La version courante du script est \`${ver}\`.\n\n`;
              out += '<div class="dl-row">\n';
              out += `  {{< btn href="${dlBase}" text="Télécharger la version courante" class="he-btn--neutral" >}}\n`;
              out += `  {{< btn href="${dlBase}.sha256" text="SHA256" class="he-btn--sm he-btn--neutral" >}}\n`;
              out += '</div>\n\n';

              return out;
            }

            async function getShaIfExists(path) {
              try {
                const { data } = await github.rest.repos.getContent({ owner, repo, path, ref: branch });
                return Array.isArray(data) ? null : (data.sha || null);
              } catch {
                return null; // not found
              }
            }

            // Log le SHA du commit créé par l'API pour visibilité
            async function upsertFile(path, content, message) {
              const sha = await getShaIfExists(path);
              const b64 = Buffer.from(content, 'utf8').toString('base64');

              const res = await github.rest.repos.createOrUpdateFileContents({
                owner, repo, path,
                branch,
                message,
                content: b64,
                sha: sha || undefined
              });

              const newSha = res?.data?.commit?.sha || 'unknown';
              core.info(`${sha ? '[UPSERTED]' : '[CREATED]'} ${path} @ ${newSha}`);
            }

            if (changed.size === 0) {
              core.info('No scripts provided in payload → nothing to upsert.');
              return;
            }

            // Upsert des scripts demandés
            let count = 0;
            for (const s of changed) {
              const md   = buildMarkdown(s, assetsMap[s] || {});
              const path = `${basePath}/${s}/index.md`;
              const msg  = `Sync mes-scripts (upsert) ${path}`;
              await upsertFile(path, md, msg);
              count++;
            }

            // Regénération de la page liste
            const scriptsAll = Object.keys(assetsMap).sort();
            let list = '';
            list += '---\n';
            list += 'title: "Mes scripts"\n';
            list += 'slug: "mes-scripts"\n';
            list += 'draft: false\n';
            list += '---\n\n';
            list += 'Liste des scripts publiés. Cliquez un script pour voir l’aide détaillée.\n\n';
            list += '| Script | Version | Description |\n';
            list += '|-------:|:--------|:------------|\n';
            for (const s of scriptsAll) {
              const meta = assetsMap[s] || {};
              const ver  = String(meta.version || 'unknown');
              const d    = String(meta.description || '').trim();
              list += `| \`${s}\` | \`${ver}\` | ${d ? d : ''} |\n`;
            }
            await upsertFile(`${basePath}/_index.md`, list, 'Sync mes-scripts (update list)');

            core.info(`Sync terminé sur ${branch} — ${count} script(s) upsert + section _index.md mise à jour.`);

      - name: Cleanup temp files
        shell: bash
        run: |
          rm -f payload.json || true

      # Pas de push local → pas de double commit / pas d'écrasement des commits API
      - name: Verify remote tip after API upserts (no push)
        shell: bash
        run: |
          set -euo pipefail
          BRANCH="${BRANCH:-${TARGET_BRANCH:-$DEFAULT_BRANCH}}"
          git fetch origin "$BRANCH" --prune
          echo "Remote tip:"
          git ls-remote origin "refs/heads/${BRANCH}"
