name: Sync mes-scripts (changed-only, scope aware)

on:
  repository_dispatch:
    types: [mes-scripts-release]
  workflow_dispatch:
    inputs:
      scope:
        description: "Scope override (auto=from payload, all=regenerate all, none=skip, list=comma-separated)"
        type: choice
        default: auto
        options:
          - auto
          - all
          - none
          - list
      scripts:
        description: "Comma-separated list (only if scope=list)"
        required: false
        type: string

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout site
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Load payload (if any)
        id: payload
        shell: bash
        run: |
          echo '--- client_payload (truncated) ---'
          cat > payload.json <<'JSON'
          ${{ toJson(github.event.client_payload) }}
          JSON
          jq -c '{source_repo,release_tag, scripts: (try .scripts // []), assets: (try .assets // {})}' payload.json || true
          echo '----------------------------------'

      - name: Sync mes-scripts content
        uses: actions/github-script@v7
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
          TARGET_BRANCH:  ${{ vars.TARGET_BRANCH }}
          SCOPE: ${{ github.event.inputs.scope || 'auto' }}
          SCRIPTS_INPUT: ${{ github.event.inputs.scripts || '' }}
        with:
          script: |
            const fs = require('fs');

            // Charge payload (ou fallback vide pour run manuel)
            const payload = fs.existsSync('payload.json')
              ? JSON.parse(fs.readFileSync('payload.json', 'utf8'))
              : { source_repo: "NoelNac-HackEthical/mes-scripts", release_tag: "", scripts: [], assets: {} };

            // ---- Gestion du scope ----
            let scope = (process.env.SCOPE || "auto").trim();
            const assetsMap = payload.assets || {};
            const allScripts = Object.keys(assetsMap).sort();
            let scripts = new Set(payload.scripts || []);

            if (scope === "none") {
              core.info("Scope=none → nothing to upsert.");
              return;
            } else if (scope === "all") {
              scripts = new Set(allScripts);
            } else if (scope === "list") {
              const raw = (process.env.SCRIPTS_INPUT || "").split(",");
              scripts = new Set();
              raw.forEach(r => {
                const s = r.trim();
                if (!s) return;
                if (allScripts.includes(s)) scripts.add(s);
                else core.warning(`Script '${s}' not found in payload.assets`);
              });
            } // default: auto → garder payload.scripts

            if (scripts.size === 0) {
              core.info("No scripts selected for update.");
              return;
            }

            const owner  = context.repo.owner;
            const repo   = context.repo.repo;
            const branch = (process.env.TARGET_BRANCH && process.env.TARGET_BRANCH.trim()) || process.env.DEFAULT_BRANCH || "main";
            const basePath = "content/mes-scripts";
            const sourceRepo = payload.source_repo || "NoelNac-HackEthical/mes-scripts";

            // Helpers
            const oneLine = (str) => {
              if (!str) return "";
              const first = String(str).split(/\r?\n/).find(l => l.trim().length > 0) || "";
              return first.trim();
            };
            const cleanVer = (v) => {
              if (!v) return "unknown";
              const m = String(v).match(/v?\d+(?:\.\d+){1,3}/i);
              return m ? (m[0].startsWith("v") ? m[0] : "v" + m[0]) : String(v);
            };
            const escapePipes = (s) => String(s || "").replace(/\|/g, " ");

            // Générateur Markdown (Description → Présentation → Usage → Télécharger)
            function buildMarkdown(scriptName, meta) {
              const verRaw = String((meta && meta.version) ? meta.version : "unknown").trim();
              const desc   = oneLine(meta && meta.description ? meta.description : "");
              const usage  = String((meta && meta.usage) ? meta.usage : "").trim();

              let out = "";
              out += "---\n";
              out += `title: "${scriptName.replace(/"/g, '\\"')}"\n`;
              out += `slug: "${scriptName.replace(/"/g, '\\"')}"\n`;
              out += "draft: false\n";
              out += "---\n\n";

              if (desc) {
                out += `> ${desc}\n\n`;
                out += "<!--more-->\n\n";
              }

              out += "## Présentation\n";
              out += "Présentation et fonctionnement de ce script.\n\n";

              out += "## Usage\n";
              out += "`" + verRaw.replace(/`/g, "\\`") + "`\n\n";
              if (usage) out += "```text\n" + usage + "\n```\n\n";

              const latestBase = "https://github.com/" + sourceRepo + "/releases/latest/download/";
              const fileEnc = encodeURIComponent(scriptName);
              const hashEnc = encodeURIComponent(scriptName + ".sha256");

              out += "## Télécharger\n\n";
              out += '<div class="dl-row">\n';
              out += `{{< btn href="${latestBase}${fileEnc}" text="Télécharger la version courante" class="he-btn--neutral" >}}\n`;
              out += `{{< btn href="${latestBase}${hashEnc}" text="SHA256" class="he-btn--sm he-btn--neutral" >}}\n`;
              out += "</div>\n\n";

              return out;
            }

            // GitHub helpers
            async function upsertOne(path, content, message) {
              const owner = context.repo.owner;
              const repo  = context.repo.repo;
              const branch = (process.env.TARGET_BRANCH && process.env.TARGET_BRANCH.trim()) || process.env.DEFAULT_BRANCH || "main";
              let sha = null;
              try {
                const res = await github.rest.repos.getContent({ owner, repo, path, ref: branch });
                if (!Array.isArray(res.data)) sha = res.data.sha || null;
              } catch (e) { /* not found */ }
              const b64 = Buffer.from(content, "utf8").toString("base64");
              const res = await github.rest.repos.createOrUpdateFileContents({
                owner, repo, path, message, content: b64, branch, sha: sha || undefined,
              });
              return res.data.commit && res.data.commit.sha;
            }

            // 1) Upsert des pages individuelles
            let count = 0;
            for (const s of scripts) {
              const path = `${basePath}/${s}/index.md`;
              const md   = buildMarkdown(s, assetsMap[s] || {});
              const msg  = `Sync mes-scripts (upsert) ${path}`;
              const sha  = await upsertOne(path, md, msg);
              core.info((sha ? "[UPSERTED] " : "[CREATED] ") + path);
              count++;
            }

            // 2) Regénérer _index.md (table)
            let lines = [];
            lines.push("---");
            lines.push('title: "Mes scripts"');
            lines.push('slug: "mes-scripts"');
            lines.push("draft: false");
            lines.push("---");
            lines.push("");
            lines.push("Liste des scripts publiés. Cliquez un script pour voir l’aide détaillée.");
            lines.push("");
            lines.push("| Script | Version | Description |");
            lines.push("|-------:|:--------|:------------|");

            for (const s of allScripts) {
              const meta = assetsMap[s] || {};
              const ver  = cleanVer(meta.version || "unknown");
              let desc   = escapePipes(oneLine(meta.description || ""));
              if (desc.length > 140) desc = desc.slice(0, 137) + "…";
              const link = "[`" + s + "`](/mes-scripts/" + encodeURIComponent(s) + "/)";
              lines.push("| " + link + " | `" + ver + "` | " + (desc ? desc : "") + " |");
            }

            await upsertOne(`${basePath}/_index.md`, lines.join("\n"), `Sync mes-scripts (upsert) ${basePath}/_index.md`);

            core.info(`Sync terminé sur ${branch} — ${count} script(s) upsert + section _index.md mise à jour.`);

      - name: Verify committed files (optional)
        shell: bash
        env:
          TARGET_BRANCH:  ${{ vars.TARGET_BRANCH }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        run: |
          BRANCH="${TARGET_BRANCH:-$DEFAULT_BRANCH}"
          git fetch --all --prune
          git checkout "$BRANCH"
          echo "--- branch: $BRANCH"
          echo '--- tree under content/mes-scripts ---'
          ls -R content/mes-scripts || true
          echo '--------------------------------------'

      - name: Sanity check download links (optional)
        shell: bash
        run: |
          SRC_REPO=$(jq -r '.source_repo // "NoelNac-HackEthical/mes-scripts"' payload.json)
          ASSETS_KEYS=$(jq -r 'keys[]' <<<"$(jq '.assets' payload.json)")
          for s in $ASSETS_KEYS; do
            for ext in "" ".sha256"; do
              url="https://github.com/${SRC_REPO}/releases/latest/download/${s}${ext}"
              code=""
              for i in $(seq 1 6); do
                code="$(curl -sS -o /dev/null -w '%{http_code}' -L "$url" || echo 000)"
                [ "$code" = "200" ] || [ "$code" = "302" ] || [ "$code" = "206" ] && break
                sleep 2
              done
              echo "$code $url"
              if [ "$code" != "200" ] && [ "$code" != "302" ] && [ "$code" != "206" ]; then
                echo "::warning ::Lien invalide (après retries): $url (HTTP $code)"
