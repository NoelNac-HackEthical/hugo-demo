name: Sync mes-scripts (changed-only, no prune)

on:
  repository_dispatch:
    types: [mes-scripts-release]

permissions:
  contents: write
  pull-requests: read

jobs:
  sync:
    runs-on: ubuntu-latest

    env:
      TARGET_BRANCH: ${{ vars.TARGET_BRANCH }}
      DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}

    steps:
      - name: Checkout site
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve TARGET_BRANCH → BRANCH (fallback to default)
        shell: bash
        run: |
          set -euo pipefail
          TB="${TARGET_BRANCH:-}"
          DB="${DEFAULT_BRANCH:-master}"
          BR="${TB:-$DB}"
          echo "TARGET_BRANCH='${TB:-<empty>}'  DEFAULT_BRANCH='$DB'  → BRANCH='$BR'"
          echo "BRANCH=$BR" >> "$GITHUB_ENV"

      - name: Decide target branch & reset from default
        shell: bash
        run: |
          set -euo pipefail
          BRANCH="${TARGET_BRANCH:-$DEFAULT_BRANCH}"

          git fetch --all --prune
          git checkout -B "$BRANCH" "origin/${DEFAULT_BRANCH}"

          echo "BRANCH=$BRANCH" >> $GITHUB_ENV
          echo "--- branch reset to origin/${DEFAULT_BRANCH} as $BRANCH"

      - name: Payload preview (optional)
        shell: bash
        run: |
          echo '--- client_payload (truncated) ---'
          cat > payload.json <<'JSON'
          ${{ toJson(github.event.client_payload) }}
          JSON
          jq -c '{scope, scripts, assets:(.assets|keys|length)}' payload.json || cat payload.json
          echo '----------------------------------'

      - name: Sync mes-scripts content (no prune, per-file upsert)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const payload = JSON.parse(fs.readFileSync('payload.json', 'utf8'));

            const owner  = context.repo.owner;
            const repo   = context.repo.repo;
            const branch = process.env.BRANCH || process.env.DEFAULT_BRANCH || 'master';

            const basePath  = 'content/mes-scripts';
            const assetsMap = payload.assets || {};
            const changed   = new Set(payload.scripts || []);

            // Nouvelle génération Markdown
            function buildMarkdown(scriptName, meta) {
              const ver   = String((meta && meta.version) || '# VERSION');
              const desc  = String((meta && meta.description) || '').trim();
              const usage = String((meta && meta.usage) || '').trim();

              let out = '';
              out += '---\n';
              out += `title: "${scriptName.replace(/"/g, '\\"')}"\n`;
              out += `slug: "${scriptName.replace(/"/g, '\\"')}"\n`;
              out += 'draft: false\n';
              out += '---\n\n';

              if (desc) out += `${desc}\n\n`;

              out += '## Présentation\n';
              out += `Présentation de mon script (${scriptName}).\n\n`;

              out += '## Usage\n';
              if (usage) {
                out += '```text\n' + usage + '\n```\n\n';
              } else {
                out += '_Aucun exemple d\'usage fourni pour l\'instant._\n\n';
              }

              const srcRepo = (meta && meta.source_repo) ? meta.source_repo : `${owner}/mes-scripts`;
              const dlBase  = `https://github.com/${srcRepo}/releases/latest/download/${scriptName}`;

              out += '## Téléchargements\n\n';
              out += `La version courante du script est \`${ver}\`.\n\n`;
              out += '<div class="dl-row">\n';
              out += `  {{< btn href="${dlBase}" text="Télécharger la version courante" class="he-btn--neutral" >}}\n`;
              out += `  {{< btn href="${dlBase}.sha256" text="SHA256" class="he-btn--sm he-btn--neutral" >}}\n`;
              out += '</div>\n\n';

              return out;
            }

            async function getShaIfExists(path) {
              try {
                const { data } = await github.rest.repos.getContent({ owner, repo, path, ref: branch });
                return Array.isArray(data) ? null : (data.sha || null);
              } catch {
                return null;
              }
            }

            async function upsertFile(path, content, message) {
              const sha = await getShaIfExists(path);
              const b64 = Buffer.from(content, 'utf8').toString('base64');

              await github.rest.repos.createOrUpdateFileContents({
                owner, repo, path,
                branch,
                message,
                content: b64,
                sha: sha || undefined
              });

              core.info((sha ? '[UPSERTED] ' : '[CREATED] ') + path);
            }

            if (changed.size === 0) {
              core.info('No scripts provided in payload → nothing to upsert.');
              return;
            }

            let count = 0;
            for (const s of changed) {
              const md   = buildMarkdown(s, assetsMap[s] || {});
              const path = `${basePath}/${s}/index.md`;
              const msg  = `Sync mes-scripts (upsert) ${path}`;
              await upsertFile(path, md, msg);
              count++;
            }

            const scriptsAll = Object.keys(assetsMap).sort();
            let list = '';
            list += '---\n';
            list += 'title: "Mes scripts"\n';
            list += 'slug: "mes-scripts"\n';
            list += 'draft: false\n';
            list += '---\n\n';
            list += 'Liste des scripts publiés. Cliquez un script pour voir l’aide détaillée.\n\n';
            list += '| Script | Version | Description |\n';
            list += '|-------:|:--------|:------------|\n';
            for (const s of scriptsAll) {
              const meta = assetsMap[s] || {};
              const ver  = String(meta.version || 'unknown');
              const desc = String(meta.description || '').trim();
              list += `| \`${s}\` | \`${ver}\` | ${desc ? desc : ''} |\n`;
            }
            await upsertFile(`${basePath}/_index.md`, list, 'Sync mes-scripts (update list)');

            core.info(`Sync terminé sur ${branch} — ${count} script(s) upsert + section _index.md mise à jour.`);

      - name: Cleanup temp files
        shell: bash
        run: |
          rm -f payload.json || true

      - name: Push branch (robuste)
        shell: bash
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          BRANCH="${BRANCH:-${TARGET_BRANCH:-$DEFAULT_BRANCH}}"

          git add -A
          if git diff --quiet --cached; then
            echo "No changes to commit."
          else
            git commit -m "Sync mes-scripts (rebased on ${DEFAULT_BRANCH})"
          fi

          git fetch origin "$BRANCH" --prune

          if git push --force-with-lease origin "$BRANCH"; then
            echo "Pushed with --force-with-lease."
          else
            echo "with-lease rejected → retrying with --force…"
            git push --force origin "$BRANCH"
          fi

      - name: Verify committed files (optional)
        shell: bash
        run: |
          set -euo pipefail
          echo "--- branch: ${BRANCH}"
          ls -R content/mes-scripts || true
