name: Sync mes-scripts pages (overwrite, minimal)

on:
  # Déclenché par le repository_dispatch envoyé depuis mes-scripts
  repository_dispatch:
    types: [mes-scripts-release]

permissions:
  contents: write  # on écrit/efface des fichiers dans le repo

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Overwrite bundles from payload (no checkout)
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // Payload attendu : { source_repo, release_tag, scripts: ["mon-nmap", "make-htb-wordlist", ...] }
            const payload = context.payload.client_payload || {};
            const scripts = Array.isArray(payload.scripts) ? payload.scripts : [];
            const tag     = payload.release_tag || "unknown-tag";
            if (scripts.length === 0) {
              core.warning("Payload.scripts est vide — rien à synchroniser.");
              return;
            }

            // Helpers ---------------------------------------------------------
            async function getDefaultBranch() {
              const repoInfo = await github.rest.repos.get({ owner, repo });
              return repoInfo.data.default_branch || "master";
            }
            async function getFileSha(path) {
              try {
                const res = await github.rest.repos.getContent({ owner, repo, path });
                if (Array.isArray(res.data)) return null;
                return res.data.sha || null;
              } catch { return null; }
            }
            async function upsertFile(path, content, message) {
              const sha = await getFileSha(path);
              const encoded = Buffer.from(content, "utf8").toString("base64");
              await github.rest.repos.createOrUpdateFileContents({
                owner, repo, path, message,
                content: encoded,
                sha: sha || undefined
              });
            }
            async function deleteFile(path, message) {
              const res = await github.rest.repos.getContent({ owner, repo, path }).catch(() => null);
              const sha = res && !Array.isArray(res.data) ? res.data.sha : null;
              if (!sha) return;
              await github.rest.repos.deleteFile({ owner, repo, path, message, sha });
            }

            // Template minimal d'un index.md (écrase l'existant)
            function renderIndexMinimal(name) {
              return [
                '---',
                `title: "${name}"`,
                `description: "Script ${name} (généré automatiquement)."`,
                'draft: false',
                '---',
                '',
                '## Télécharger',
                '',
                `{{< gh_asset repo="NoelNac-HackEthical/mes-scripts" name="${name}" label="${name}" >}}`,
                '',
                '> Cette page est générée automatiquement à partir de la dernière release de **mes-scripts**.',
                ''
              ].join('\n');
            }

            // 1) Lister l'existant pour purger ce qui n'est plus publié --------
            const defaultBranch = await getDefaultBranch();
            const ref = await github.rest.git.getRef({ owner, repo, ref: `heads/${defaultBranch}` });
            const commitSha = ref.data.object.sha;

            const tree = await github.rest.git.getTree({
              owner, repo, tree_sha: commitSha, recursive: "1"
            });

            const existingFiles = new Set(); // content/mes-scripts/<script>/index.md
            for (const item of tree.data.tree) {
              if (item.type === "blob"
                  && item.path.startsWith("content/mes-scripts/")
                  && item.path.endsWith("/index.md")) {
                existingFiles.add(item.path);
              }
            }

            // 2) Upsert tous les scripts du payload ----------------------------
            for (const s of scripts) {
              const path = `content/mes-scripts/${s}/index.md`;
              const body = renderIndexMinimal(s);
              const msg  = `chore(mes-scripts): overwrite ${path} from ${tag}`;
              await upsertFile(path, body, msg);
              core.info(`[UPSERT] ${path}`);
            }

            // 3) Supprimer les pages qui ne sont plus dans la liste ------------
            const desiredSet = new Set(scripts);
            const toDelete = [...existingFiles].filter(p => {
              const parts = p.split('/');
              const scriptName = parts[2]; // content/mes-scripts/<script>/index.md
              return !desiredSet.has(scriptName);
            });

            for (const path of toDelete) {
              const msg = `chore(mes-scripts): remove ${path} (not in ${tag})`;
              await deleteFile(path, msg);
              core.info(`[DELETE] ${path}`);
            }

            core.info(`Sync terminé. ${scripts.length} script(s) sur ${defaultBranch}.`);
